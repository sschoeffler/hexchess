console.log('ðŸš€ COMPLETE game.js loaded');

// =============================================================================
// GLOBAL VARIABLES
// =============================================================================
let selectedHex = null;
let gameOverDetected = false;

// Board configuration constants
const BOARD_PLAYER_LIMITS = {
    4: { min: 2, max: 3, name: "Mini" },
    5: { min: 2, max: 3, name: "Small" },
    6: { min: 2, max: 3, name: "Medium" },
    7: { min: 2, max: 6, name: "Large" },
    8: { min: 2, max: 6, name: "Jumbo" }
};

// =============================================================================
// AUTHENTICATION FUNCTIONS
// =============================================================================
function showAuth(type) {
    document.getElementById('loginForm').style.display = type === 'login' ? 'block' : 'none';
    document.getElementById('registerForm').style.display = type === 'register' ? 'block' : 'none';
}

function login(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'login');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            showNotification('Login Failed', data.error, 'error');
        }
    });
}

function register(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'register');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            showNotification('Registration Failed', data.error, 'error');
        }
    });
}

function logout() {
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'action=logout'
    })
    .then(() => location.reload());
}

// =============================================================================
// LOBBY & GAME CREATION FUNCTIONS
// =============================================================================

function showValidationError(message) {
    // Remove existing error
    const existingError = document.querySelector('.validation-error');
    if (existingError) {
        existingError.remove();
    }
    
    // Create error element
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error';
    errorDiv.style.cssText = `
        background: rgba(231, 76, 60, 0.2);
        border: 2px solid #e74c3c;
        border-radius: 8px;
        padding: 12px;
        margin: 10px 0;
        color: #fff;
        font-size: 14px;
        text-align: center;
        animation: errorShake 0.5s ease-in-out;
    `;
    errorDiv.textContent = message;
    
    // Insert before submit button
    const form = document.querySelector('form');
    const submitBtn = form.querySelector('button[type="submit"]');
    form.insertBefore(errorDiv, submitBtn);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (errorDiv.parentElement) {
            errorDiv.remove();
        }
    }, 5000);
}

function updateEnhancedGameModeOptions() {
    const gameType = document.getElementById('game_type');
    const playersGroup = document.getElementById('players-group');
    const aiDifficultyGroup = document.getElementById('ai-difficulty-group');
    const playerCount = document.getElementById('player_count');
    
    if (!gameType || !playersGroup || !aiDifficultyGroup || !playerCount) {
        return; // Safety check
    }
    
    const gameTypeValue = gameType.value;
    
    // Clear validation errors
    const existingError = document.querySelector('.validation-error');
    if (existingError) existingError.remove();
    
    // Show/hide AI difficulty
    if (gameTypeValue === 'vs_ai') {
        aiDifficultyGroup.style.display = 'block';
        playerCount.innerHTML = '<option value="2">2 Players</option>';
        playerCount.value = '2';
        playersGroup.style.display = 'none';
    } else {
        aiDifficultyGroup.style.display = 'none';
        playersGroup.style.display = 'block';
        updatePlayerOptions();
    }
    
    updateTimerVisibility();
    updateEnhancedDefaultGameName();
}

function updatePlayerOptions() {
    const boardSizeSelect = document.getElementById('board_size');
    const playerCountSelect = document.getElementById('player_count');
    const gameTypeSelect = document.getElementById('game_type');
    
    if (!boardSizeSelect || !playerCountSelect || !gameTypeSelect) return;
    
    const boardSize = parseInt(boardSizeSelect.value);
    const gameType = gameTypeSelect.value;
    
    if (gameType === 'vs_ai') return;
    
    const limits = BOARD_PLAYER_LIMITS[boardSize];
    if (!limits) return;
    
    const currentValue = parseInt(playerCountSelect.value);
    playerCountSelect.innerHTML = '';
    
    for (let i = limits.min; i <= limits.max; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i} Players`;
        playerCountSelect.appendChild(option);
    }
    
    if (currentValue >= limits.min && currentValue <= limits.max) {
        playerCountSelect.value = currentValue;
    } else {
        playerCountSelect.value = currentValue > limits.max ? limits.max : limits.min;
    }
    
    updateTimerVisibility();
    updateEnhancedDefaultGameName();
}

function updateTimerVisibility() {
    const playerCount = parseInt(document.getElementById('player_count').value);
    const timerSettings = document.getElementById('timer-settings');
    if (!timerSettings) return;
    timerSettings.style.display = (playerCount >= 4) ? 'block' : 'none';
}

function updateEnhancedDefaultGameName() {
    const gameType = document.getElementById('game_type');
    const playerCount = document.getElementById('player_count');
    const boardSize = document.getElementById('board_size');
    const aiDifficulty = document.getElementById('ai_difficulty');
    const gameNameField = document.getElementById('game_name');
    const fogOfWarCheckbox = document.getElementById('fog_of_war');
    const shogiDropsCheckbox = document.getElementById('shogi_drops');
    
    if (!gameType || !playerCount || !boardSize || !gameNameField) return;

    const currentValue = gameNameField.value.trim();
    
    // Check if current value is a default name (should be replaced)
    const isDefaultName = currentValue === '' ||
        currentValue.match(/^(Online|vs AI|Hotseat|\w+ AI).*(Mini|Small|Medium|Large|Jumbo).*$/) ||
        currentValue.match(/^\d+-Player (Mini|Small|Medium|Large|Jumbo) Game.*$/) ||
        currentValue.match(/^(Online|Hotseat) \d+P (Mini|Small|Medium|Large|Jumbo).*$/) ||
        currentValue.match(/^TEST \d+$/);

    if (!isDefaultName) return; // Don't replace custom names
    
    const sizeName = (BOARD_PLAYER_LIMITS[boardSize.value] || {}).name || 'Large';
    let defaultName = '';
    
    if (gameType.value === 'vs_ai') {
        const difficultyName = aiDifficulty ? aiDifficulty.value.charAt(0).toUpperCase() + aiDifficulty.value.slice(1) : 'Player';
        defaultName = `${difficultyName} AI ${sizeName}`;
    } else {
        const typeName = (gameType.value === 'hotseat') ? 'Hotseat' : 'Online';
        defaultName = `${typeName} ${playerCount.value}P ${sizeName}`;
    }
    
    // Add hexchess option indicators
    const options = [];
    if (fogOfWarCheckbox && fogOfWarCheckbox.checked) {
        options.push('Fog');
    }
    if (shogiDropsCheckbox && shogiDropsCheckbox.checked) {
        options.push('Drops');
    }
    
    if (options.length > 0) {
        defaultName += ` (${options.join(', ')})`;
    }
    
    gameNameField.value = defaultName;
}

function resetToEnhancedDefaultName() {
    const gameNameField = document.getElementById('game_name');
    if (!gameNameField) return;
    
    gameNameField.value = '';
    updateEnhancedDefaultGameName();
}

function createEnhancedGame(event) {
    event.preventDefault();

    // Define formData FIRST
    const formData = new FormData(event.target);
    const boardSize = parseInt(formData.get('board_size'));
    const playerCount = parseInt(formData.get('player_count'));
    const gameType = formData.get('game_type');

    // Board size validation
    if (gameType !== 'vs_ai') {
        const limits = BOARD_PLAYER_LIMITS[boardSize];
        if (limits && playerCount > limits.max) {
            showValidationError(`${limits.name} board supports maximum ${limits.max} players. Selected: ${playerCount} players.`);
            return;
        }
    }

    // Prepare game data with hexchess options
    const gameData = {
        action: 'create_game',
        room_name: formData.get('room_name') || `${playerCount}-Player Game`,
        player_count: formData.get('player_count'),
        board_size: formData.get('board_size'),
        ai_difficulty: formData.get('ai_difficulty') || 'medium',
        game_type: formData.get('game_type'),
        turn_timer: formData.get('turn_timer') || '30',
        skip_action: formData.get('skip_action') || 'skip_turn',
        
        // ADD HEXCHESS OPTIONS:
        fog_of_war: formData.get('fog_of_war') ? '1' : '0',
        shogi_drops: formData.get('shogi_drops') ? '1' : '0'
    };

    const btn = event.target.querySelector('button[type="submit"]');
    const txt = btn.textContent;
    btn.disabled = true; 
    btn.textContent = 'Creating...';

    fetch('', {
        method: 'POST',
        headers: {'Content-Type':'application/x-www-form-urlencoded'},
        body: new URLSearchParams(gameData)
    })
    .then(r => r.json())
    .then(data => {
        if (data.success) {
            window.location.href = `?page=game&id=${data.game_id}`;
        } else {
            showValidationError(data.error || 'Failed to create game');
        }
    })
    .catch(() => showValidationError('Network error: Could not connect to server'))
    .finally(() => { 
        btn.disabled = false; 
        btn.textContent = txt; 
    });
}

// Legacy game creation function (for compatibility)
function createGame(event) {
    return createEnhancedGame(event);
}

function loadAvailableGames() {
    console.log('Loading available games...');
    
    fetch(window.location.pathname + '?api=games')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(games => {
            const gameList = document.getElementById('available-games');
            if (!gameList) {
                return;
            }
            
            if (games.length === 0) {
                gameList.innerHTML = '<p>No games available. Create one!</p>';
                return;
            }
            
            const gameHtml = games.map(game => `
                <div class="game-item">
                    <div class="game-info">
                        <h3>${game.game_name}</h3>
                        <p>${game.current_players}/${game.player_count} players</p>
                        <small>Created by ${game.creator}${game.player_names ? ' â€¢ Players: ' + game.player_names : ''}</small>
                    </div>
                    <button class="btn" onclick="joinGame('${game.game_id}')">Join</button>
                </div>
            `).join('');

            gameList.innerHTML = gameHtml;
        })
        .catch(error => {
            console.error('Error loading games:', error);
            const gameList = document.getElementById('available-games');
            if (gameList) {
                gameList.innerHTML = '<p>Error loading games. Check console.</p>';
            }
        });
}

function loadMyGames() {
    console.log('Loading my active games...');
    
    fetch(window.location.pathname + '?api=my-games')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                console.error('Error from server:', data.error);
                const gameList = document.getElementById('my-games');
                if (gameList) {
                    gameList.innerHTML = '<p>Error: ' + data.error + '</p>';
                }
                return;
            }
            
            const games = data;
            const gameList = document.getElementById('my-games');
            if (!gameList) {
                return;
            }
            
            if (games.length === 0) {
                gameList.innerHTML = '<p>No active games. Join or create one!</p>';
                return;
            }
            
            const gameHtml = games.map(game => {
                let statusText = '';
                let buttonText = '';
                let buttonClass = 'btn';
                
                if (game.status === 'waiting') {
                    statusText = `Waiting for ${game.player_count - game.current_players} more player(s)`;
                    buttonText = 'Enter Waiting Room';
                } else if (game.status === 'active') {
                    statusText = game.is_your_turn ? 'Your turn!' : 'Waiting for other player';
                    buttonText = 'Resume Game';
                    buttonClass = game.is_your_turn ? 'btn' : 'btn btn-secondary';
                } else if (game.status === 'finished') {
                    statusText = game.winner_name ? `Won by ${game.winner_name}` : 'Game ended';
                    buttonText = 'View Game';
                    buttonClass = 'btn btn-secondary';
                }
                
                return `
                    <div class="game-item ${game.is_your_turn ? 'your-turn' : ''}">
                        <div class="game-info">
                            <h3>${game.game_name}</h3>
                            <p>${statusText}</p>
                            <small>${game.player_names || `${game.current_players}/${game.player_count} players`} â€¢ ${game.status}</small>
                        </div>
                        <button class="${buttonClass}" onclick="resumeGame('${game.game_id}')">${buttonText}</button>
                    </div>
                `;
            }).join('');

            gameList.innerHTML = gameHtml;
        })
        .catch(error => {
            console.error('Error loading my games:', error);
            const gameList = document.getElementById('my-games');
            if (gameList) {
                gameList.innerHTML = '<p>Error loading your games. Try refreshing.</p>';
            }
        });
}

function joinGame(gameId) {
    console.log('Joining game:', gameId);
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=join_game&game_id=${gameId}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `?page=game&id=${gameId}`;
        } else {
            showNotification('Failed to Join', data.error, 'error');
        }
    });
}

function resumeGame(gameId) {
    console.log('Resuming game:', gameId);
    window.location.href = `?page=game&id=${gameId}`;
}

function resignGame() {
    if (!confirm('âš ï¸ Are you sure you want to resign?\n\nThis will end the game and count as a loss for you. This action cannot be undone.')) {
        return;
    }
    
    console.log('Resigning from game:', gameId);
    
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn) {
        resignBtn.disabled = true;
        resignBtn.textContent = 'Resigning...';
    }
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=resign&game_id=${gameId}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('Game Resigned', data.message || 'You have resigned from the game', 'info');
        } else {
            showNotification('Resignation Failed', data.error, 'error');
            if (resignBtn) {
                resignBtn.disabled = false;
                resignBtn.textContent = 'Resign Game';
            }
        }
    })
    .catch(error => {
        console.error('Resignation error:', error);
        showNotification('Connection Error', 'Unable to resign from game', 'error');
        if (resignBtn) {
            resignBtn.disabled = false;
            resignBtn.textContent = 'Resign Game';
        }
    });
}

// =============================================================================
// GAME PLAY FUNCTIONS
// =============================================================================

function selectHex(q, r) {
    console.log('selectHex called:', q, r, 'gameId:', typeof gameId !== 'undefined' ? gameId : 'UNDEFINED');
    
    if (typeof userCanMove !== 'undefined' && !userCanMove) {
        showNotification('Not Your Turn', 'Wait for your turn to move', 'warning');
        return;
    }
    
    const cell = document.querySelector(`[data-q="${q}"][data-r="${r}"]`);
    if (!cell) {
        console.error('Cell not found for coordinates:', q, r);
        return;
    }
    
    // If clicking the same hex, deselect it
    if (selectedHex && selectedHex.q === q && selectedHex.r === r) {
        clearSelection();
        return;
    }
    
    // If we have a selected piece and clicked on a valid move, make the move
    if (selectedHex && cell.classList.contains('valid-move')) {
        makeMove(selectedHex.q, selectedHex.r, q, r);
        return;
    }
    
    // Check if there's actually a piece at this position
    const piece = cell.querySelector('.piece');
    if (!piece) {
        clearSelection();
        return; // No piece here, don't show any moves
    }
    
    // Select this piece and show its valid moves
    clearSelection();
    selectedHex = {q: q, r: r};
    cell.classList.add('selected');
    
    if (typeof gameId !== 'undefined' && gameId) {
        getValidMoves(q, r);
    } else {
        // For demo mode, highlight some example moves
        highlightValidMoves(q, r);
    }
}

function clearSelection() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        cell.classList.remove('selected', 'valid-move');
    });
    selectedHex = null;
}

function clearCheckHighlights() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        cell.classList.remove('king-in-check');
    });
}

function highlightValidMoves(q, r) {
    const directions = [
        [1, 0], [1, -1], [0, -1], [-1, 0], [-1, 1], [0, 1],
        [2, -1], [1, -2], [-1, -1], [-2, 1], [-1, 2], [1, 1]
    ];
    
    directions.forEach(([dq, dr]) => {
        const newQ = q + dq;
        const newR = r + dr;
        const targetCell = document.querySelector(`[data-q="${newQ}"][data-r="${newR}"]`);
        if (targetCell) {
            targetCell.classList.add('valid-move');
        }
    });
}

function getValidMoves(q, r) {
    console.log('Getting valid moves for:', q, r, 'gameId:', gameId);
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=getValidMoves&game_id=${gameId}&fromQ=${q}&fromR=${r}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.validMoves && data.validMoves.length > 0) {
            console.log('Found', data.validMoves.length, 'valid moves');
            data.validMoves.forEach(move => {
                const targetCell = document.querySelector(`[data-q="${move.q}"][data-r="${move.r}"]`);
                if (targetCell) {
                    targetCell.classList.add('valid-move');
                }
            });
        } else {
            console.log('No valid moves or error:', data);
            clearSelection();
        }
    })
    .catch(error => {
        console.error('Fetch error:', error);
        clearSelection();
    });
}

function makeMove(fromQ, fromR, toQ, toR) {
    console.log('Making move:', fromQ, fromR, 'â†’', toQ, toR);
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=move&game_id=${gameId}&fromQ=${fromQ}&fromR=${fromR}&toQ=${toQ}&toR=${toR}`
    })
    .then(response => response.json())
    .then(data => {
        console.log('Move response:', data);
        
        // Always log debug info if available
        if (data.debug) {
            console.log('ðŸ” MOVE DEBUG:', data.debug);
            
            // Log specific details
            if (data.debug.piece) {
                console.log('ðŸ“‹ Piece:', data.debug.piece);
            }
            if (data.debug.step) {
                console.log('ðŸ“ Failed at step:', data.debug.step);
            }
        }
        
        if (data.success) {
            console.log('âœ… Move successful - reloading page');
            setTimeout(() => {
                location.reload();
            }, 500);
        } else {
            console.error('âŒ Move failed:', data.error);
            showNotification('Invalid Move', data.error, 'error');
        }
        clearSelection();
    })
    .catch(error => {
        console.error('ðŸŒ Network error:', error);
        showNotification('Connection Error', 'Unable to make move', 'error');
        clearSelection();
    });
}

/*
function makeMove(fromQ, fromR, toQ, toR) {
    console.log('Making move:', fromQ, fromR, 'â†’', toQ, toR);
    
    // Check if game is over before making any move
    if (isGameOver()) {
        console.log('Game is over, not making move');
        clearSelection();
        return;
    }
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=move&game_id=${gameId}&fromQ=${fromQ}&fromR=${fromR}&toQ=${toQ}&toR=${toR}`
    })
    .then(response => response.json())
    .then(data => {
        console.log('Move response:', data);
        
        if (data.success) {
            console.log('Move successful');
            setTimeout(() => {
                location.reload();
            }, 500);
        } else {
            // Only show notifications for errors
            if (data.errorType === 'exposes-king') {
                showNotification('King in Danger!', 'That move would expose your king to check', 'warning');
            } else if (data.errorType === 'wrong-player') {
                showNotification('Wrong Piece', 'You can only move your own pieces', 'error');
            } else if (data.errorType === 'no-piece') {
                showNotification('No Piece', 'No piece at selected position', 'error');
            } else {
                showNotification('Invalid Move', data.error || 'Move not allowed', 'error');
            }
        }
        clearSelection();
    })
    .catch(error => {
        console.error('Move error:', error);
        showNotification('Connection Error', 'Unable to make move', 'error');
        clearSelection();
    });
}
*/

// =============================================================================
// GAME STATE & OVER DETECTION
// =============================================================================

function isGameOver() {
    // If we already detected game over, stay that way
    if (gameOverDetected) {
        return true;
    }
    
    // Check for game over indicators in the page
    const gameStatus = document.getElementById('gameStatusText');
    if (gameStatus) {
        const statusText = gameStatus.textContent.toLowerCase();
        if (statusText.includes('game over') || 
            statusText.includes('checkmate') || 
            statusText.includes('stalemate') ||
            statusText.includes('wins') ||
            statusText.includes('resigned') ||
            statusText.includes('game ended') ||
            statusText.includes('victory') ||
            statusText.includes('defeat')) {
            console.log('Game over detected from status text:', statusText);
            gameOverDetected = true;
            return true;
        }
    }
    
    // Check for game over elements
    const gameOverElements = document.querySelectorAll('[class*="game-over"], [class*="ended"], [class*="finished"], [class*="checkmate"], [class*="stalemate"]');
    if (gameOverElements.length > 0) {
        console.log('Game over detected from elements');
        gameOverDetected = true;
        return true;
    }
    
    // Check if userCanMove is defined and game status indicates game over
    if (typeof userCanMove !== 'undefined' && typeof gameOver !== 'undefined' && gameOver) {
        console.log('Game over detected from gameOver variable');
        gameOverDetected = true;
        return true;
    }
    
    // Check for resign button being hidden (might indicate game over)
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn && resignBtn.style.display === 'none') {
        console.log('Game over detected from hidden resign button');
        gameOverDetected = true;
        return true;
    }
    
    return false;
}

function checkAndHandleGameOver() {
    const gameStatus = document.getElementById('gameStatusText');
    if (!gameStatus) return false;
    
    const statusText = gameStatus.textContent.toLowerCase();
    
    // Detect different game over scenarios
    if (statusText.includes('checkmate')) {
        if (statusText.includes('red') || statusText.includes('you')) {
            showCheerfulGameOver('Checkmate! Red Wins!', 'victory');
        } else if (statusText.includes('blue') || statusText.includes('ai')) {
            showCheerfulGameOver('Checkmate! Blue Wins!', 'defeat');
        } else {
            showCheerfulGameOver('Checkmate! Game Over!', 'neutral');
        }
        return true;
    }
    
    if (statusText.includes('stalemate')) {
        showCheerfulGameOver('Stalemate! It\'s a Draw!', 'draw');
        return true;
    }
    
    if (statusText.includes('resigned')) {
        if (statusText.includes('blue') || statusText.includes('ai')) {
            showCheerfulGameOver('Blue Resigns! Red Wins!', 'victory');
        } else {
            showCheerfulGameOver('Red Resigns! Blue Wins!', 'defeat');
        }
        return true;
    }
    
    if (statusText.includes('wins')) {
        if (statusText.includes('red')) {
            showCheerfulGameOver('Red Wins! Congratulations!', 'victory');
        } else if (statusText.includes('blue')) {
            showCheerfulGameOver('Blue Wins! Well Played!', 'defeat');
        } else {
            showCheerfulGameOver('Game Complete!', 'neutral');
        }
        return true;
    }
    
    return false;
}

function showCheerfulGameOver(message, type) {
    console.log('Game over:', message);
    
    // Update the game status with cheerful message
    const gameStatus = document.getElementById('gameStatusText');
    if (gameStatus) {
        gameStatus.innerHTML = `<div style="
            font-size: 18px; 
            font-weight: bold; 
            color: ${type === 'victory' ? '#4CAF50' : type === 'defeat' ? '#2196F3' : type === 'draw' ? '#FF9800' : '#333'};
            text-align: center;
            padding: 15px;
            background: ${type === 'victory' ? 'rgba(76, 175, 80, 0.1)' : type === 'defeat' ? 'rgba(33, 150, 243, 0.1)' : 'rgba(255, 152, 0, 0.1)'};
            border-radius: 8px;
            border: 2px solid ${type === 'victory' ? '#4CAF50' : type === 'defeat' ? '#2196F3' : type === 'draw' ? '#FF9800' : '#333'};
            margin: 10px 0;
        ">${message}</div>`;
    }
    
    // Hide resign button since game is over
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn) {
        resignBtn.style.display = 'none';
    }
    
    // Show a brief notification too
    showNotification('Game Complete', message.replace(/[^a-zA-Z\s!]/g, '').trim(), 
                    type === 'victory' ? 'success' : type === 'defeat' ? 'info' : 'warning');
}

function highlightKingsInCheck(kingsInCheck) {
    clearCheckHighlights();
    kingsInCheck.forEach(king => {
        const kingCell = document.querySelector(`[data-q="${king.q}"][data-r="${king.r}"]`);
        if (kingCell) {
            kingCell.classList.add('king-in-check');
        }
    });
}

function updateGameState(gameState) {
    if (gameState.gameStatus.gameOver) {
        console.log('Game over detected in updateGameState');
        
        // Let the checkAndHandleGameOver function handle the messaging
        setTimeout(() => {
            checkAndHandleGameOver();
        }, 100);
        
        if (typeof userCanMove !== 'undefined') {
            userCanMove = false;
        }
        
        // Hide the resign button since game is over
        const resignBtn = document.querySelector('button[onclick="resignGame()"]');
        if (resignBtn) {
            resignBtn.style.display = 'none';
        }
    }
}

// =============================================================================
// DEMO FUNCTIONS
// =============================================================================

function showPiece(pieceType) {
    console.log('showPiece called for:', pieceType);
    
    if (window.demoProcessing) {
        return;
    }
    
    window.demoProcessing = true;
    
    try {
        // Update UI
        document.querySelectorAll('.piece-nav-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        const navButton = document.getElementById(`nav-${pieceType}`);
        if (navButton) {
            navButton.classList.add('active');
        }
        
        document.querySelectorAll('.piece-desc').forEach(desc => {
            desc.classList.remove('active');
        });
        
        const descElement = document.getElementById(`desc-${pieceType}`);
        if (descElement) {
            descElement.classList.add('active');
        }
        
        // Clear highlights
        document.querySelectorAll('.hex-cell').forEach(cell => {
            cell.classList.remove('selected', 'valid-move', 'capture-square');
        });
        
        // Update piece and show pattern
        updateBoardPiece(pieceType);
        showMovementPattern(pieceType);
        
        console.log('Demo complete for:', pieceType);
        
    } catch (error) {
        console.error('Error:', error);
    } finally {
        setTimeout(() => {
            window.demoProcessing = false;
        }, 100);
    }
}

function updateBoardPiece(pieceType) {
    let demoQ, demoR;
    switch (pieceType) {
        case 'pawn':
            demoQ = -5; demoR = 0;
            break;
        default:
            demoQ = 0; demoR = 0;
    }
    
    // Clear all pieces first
    document.querySelectorAll('.hex-content').forEach(content => {
        content.innerHTML = '';
    });
    
    // Place new piece - ONLY add data-piece attribute, NO text content
    const pieceCell = document.querySelector(`[data-q="${demoQ}"][data-r="${demoR}"]`);
    if (pieceCell) {
        const pieceContent = pieceCell.querySelector('.hex-content');
        if (pieceContent) {
            // Create piece element with ONLY the data-piece attribute - let CSS handle the symbol
            pieceContent.innerHTML = `<span class='piece red-piece' data-piece='${pieceType}'></span>`;
        }
    }
}

function showMovementPattern(pieceType) {
    let demoQ, demoR;
    switch (pieceType) {
        case 'pawn':
            demoQ = -5; demoR = 0;
            break;
        default:
            demoQ = 0; demoR = 0;
    }
    
    // Highlight piece position
    const pieceCell = document.querySelector(`[data-q="${demoQ}"][data-r="${demoR}"]`);
    if (pieceCell) {
        pieceCell.classList.add('selected');
    }
    
    // Get moves and highlight them
    const validMoves = getValidMovesForPiece(pieceType, demoQ, demoR);
    
    console.log(`${pieceType} valid moves:`, validMoves.length);
    
    validMoves.forEach(move => {
        const cell = document.querySelector(`[data-q="${move.q}"][data-r="${move.r}"]`);
        if (cell) {
            if (move.type === 'capture') {
                cell.classList.add('capture-square');
            } else {
                cell.classList.add('valid-move');
            }
        }
    });
}

function getValidMovesForPiece(pieceType, fromQ, fromR) {
    const moves = [];
    
    switch (pieceType) {
        case 'pawn':
            moves.push({q: fromQ + 1, r: fromR, type: 'move'});
            moves.push({q: fromQ + 1, r: fromR + 1, type: 'capture'});
            moves.push({q: fromQ + 2, r: fromR - 1, type: 'capture'});
            break;
            
        case 'bishop':
            const bishopDirections = [
                [1, 1], [-1, -1],
                [2, -1], [-2, 1],
                [1, -2], [-1, 2]
            ];
            
            bishopDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'queen':
            const queenDirections = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1],
                [1, 1], [-1, -1], [2, -1], [-2, 1], [1, -2], [-1, 2]
            ];
            
            queenDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'rook':
            const rookDirections = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]
            ];
            
            rookDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'knight':
            const knightMoves = [
                [2, 1], [3, -1], [1, 2], [-1, 3],
                [-2, 3], [-3, 2], [-3, 1], [-2, -1],
                [-1, -2], [1, -3], [2, -3], [3, -2]
            ];
            
            knightMoves.forEach(([dq, dr]) => {
                const newQ = fromQ + dq;
                const newR = fromR + dr;
                
                if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                    moves.push({q: newQ, r: newR, type: 'move'});
                }
            });
            break;
            
        case 'king':
            const kingMoves = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1],
                [1, 1], [-1, -1], [2, -1], [-2, 1], [1, -2], [-1, 2]
            ];
            
            kingMoves.forEach(([dq, dr]) => {
                const newQ = fromQ + dq;
                const newR = fromR + dr;
                
                if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                    moves.push({q: newQ, r: newR, type: 'move'});
                }
            });
            break;
    }
    
    return moves;
}

function initializeDemoPage() {
    console.log('Initializing demo page with king moves');
    
    setTimeout(() => {
        showPiece('king');
    }, 500);
}

function showPieceDemo(pieceType) {
    showPiece(pieceType);
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

function showNotification(title, message, type = 'error') {
    console.log(`Notification: ${title} - ${message}`);
    
    const existing = document.querySelector('.notification');
    if (existing) existing.remove();
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 100);
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

function applyHoverEffects() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        // Remove any existing event listeners to prevent duplicates
        cell.removeEventListener('mouseenter', handlePieceHover);
        cell.removeEventListener('mouseleave', handlePieceLeave);
        
        // Add the hover event listeners
        cell.addEventListener('mouseenter', handlePieceHover);
        cell.addEventListener('mouseleave', handlePieceLeave);
    });
}

function handlePieceHover() {
    const piece = this.querySelector('.piece');
    if (piece) {
        // Combine centering AND scaling transforms
        piece.style.transform = 'translate(-50%, -50%) scale(1.15)';
        piece.style.transition = 'transform 0.2s ease';
    }
}

function handlePieceLeave() {
    const piece = this.querySelector('.piece');
    if (piece) {
        // Reset to just centering transform
        piece.style.transform = 'translate(-50%, -50%) scale(1)';
    }
}

function isValidHex(q, r) {
    const BOARD_SIZE = 8;
    return Math.abs(q) <= BOARD_SIZE && 
           Math.abs(r) <= BOARD_SIZE && 
           Math.abs(q + r) <= BOARD_SIZE;
}

function getCellColor(q, r) {
    const colorIndex = ((q - r) % 3 + 3) % 3;
    const colors = ['pastel-red', 'pastel-green', 'pastel-blue'];
    return colors[colorIndex];
}

// =============================================================================
// INITIALIZATION & STYLING
// =============================================================================

// Add CSS for error animation
const style = document.createElement('style');
style.textContent = `
@keyframes errorShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}
`;
document.head.appendChild(style);

// Add viewport meta tag if missing (helps with mobile rendering)
if (!document.querySelector('meta[name="viewport"]')) {
    const viewport = document.createElement('meta');
    viewport.name = 'viewport';
    viewport.content = 'width=device-width, initial-scale=1.0, user-scalable=no';
    document.head.appendChild(viewport);
}

// =============================================================================
// MAIN EVENT LISTENER - SINGLE DOMContentLoaded
// =============================================================================

document.addEventListener('DOMContentLoaded', function() {
    console.log('Game.js initialized');
    
    // Check if we're on a lobby page
    const gameTypeElement = document.getElementById('game_type');
    if (gameTypeElement) {
        console.log('Lobby page detected, setting up enhanced room creation...');
        
        // Set up event listeners for lobby form elements
        const playerCountSelect = document.getElementById('player_count');
        const boardSizeSelect = document.getElementById('board_size');
        const aiDifficultySelect = document.getElementById('ai_difficulty');
        const fogOfWarCheckbox = document.getElementById('fog_of_war');
        const shogiDropsCheckbox = document.getElementById('shogi_drops');
        
        if (gameTypeElement) {
            gameTypeElement.addEventListener('change', updateEnhancedGameModeOptions);
            console.log('Game type listener attached');
        }
        
        if (playerCountSelect) {
            playerCountSelect.addEventListener('change', function() {
                console.log('Player count changed to:', this.value);
                updateTimerVisibility();
                updateEnhancedDefaultGameName();
                const existingError = document.querySelector('.validation-error');
                if (existingError) existingError.remove();
            });
            console.log('Player count listener attached');
        }
        
        if (boardSizeSelect) {
            boardSizeSelect.addEventListener('change', function() {
                console.log('Board size changed to:', this.value);
                updatePlayerOptions();
                const existingError = document.querySelector('.validation-error');
                if (existingError) existingError.remove();
            });
            console.log('Board size listener attached');
        }
        
        if (aiDifficultySelect) {
            aiDifficultySelect.addEventListener('change', function() {
                console.log('AI difficulty changed to:', this.value);
                updateEnhancedDefaultGameName();
            });
            console.log('AI difficulty listener attached');
        }
        
        if (fogOfWarCheckbox) {
            fogOfWarCheckbox.addEventListener('change', function() {
                console.log('Fog of War changed to:', this.checked);
                updateEnhancedDefaultGameName();
            });
            console.log('Fog of War listener attached');
        }
        
        if (shogiDropsCheckbox) {
            shogiDropsCheckbox.addEventListener('change', function() {
                console.log('Shogi Drops changed to:', this.checked);
                updateEnhancedDefaultGameName();
            });
            console.log('Shogi Drops listener attached');
        }
        
        // Initialize form state
        setTimeout(() => {
            console.log('Initializing room name...');
            updateEnhancedDefaultGameName();
            console.log('Room name initialized');
        }, 100);
        
        console.log('Enhanced room creation system ready!');
        
        // Load game lists
        if (document.getElementById('available-games')) {
            loadAvailableGames();
        }
        
        if (document.getElementById('my-games')) {
            loadMyGames();
        }
    } else {
        console.log('Not on lobby page, skipping enhanced room creation');
        
        // Initialize game-specific variables from data attributes
        const root = document.getElementById('hexchess-root');
        if (root) {
            window.gameId = root.dataset.gameId || undefined;
            window.userCanMove = root.dataset.userCanMove === '1';
            window.gameMode = root.dataset.gameMode || 'multiplayer';
            window.isAIGame = (window.gameMode === 'ai');
            window.currentPlayerSlot = Number(root.dataset.currentPlayerSlot ?? 0);
            window.userPlayerSlot = Number(root.dataset.userPlayerSlot ?? -1);
            window.aiPlayerSlot = root.dataset.aiPlayerSlot === '' ? null : Number(root.dataset.aiPlayerSlot);

            // Hotseat should always be tappable on this device
            if (window.gameMode === 'hotseat') window.userCanMove = true;
        }

        // Apply hover effects for game pages
        applyHoverEffects();
        
        // Demo page auto-init
        if (window.location.search.includes('page=demo')) {
            console.log('Demo page detected, will auto-show king moves');
            initializeDemoPage();
        }
        
        // Check for game over state on page load
        setTimeout(() => {
            if (isGameOver()) {
                console.log('Game over detected on page load');
                checkAndHandleGameOver();
            }
        }, 1000);
    }
});

console.log('Complete game.js loaded successfully');