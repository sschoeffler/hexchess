console.log('ğŸš€ COMPLETE game.js loaded');

// Global variables
let selectedHex = null;
let gameOverDetected = false;

// Auth functions
function showAuth(type) {
    document.getElementById('loginForm').style.display = type === 'login' ? 'block' : 'none';
    document.getElementById('registerForm').style.display = type === 'register' ? 'block' : 'none';
}

function login(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'login');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            showNotification('Login Failed', data.error, 'error');
        }
    });
}

function register(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'register');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            showNotification('Registration Failed', data.error, 'error');
        }
    });
}

function logout() {
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'action=logout'
    })
    .then(() => location.reload());
}

// Game creation
function createGame(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'create_game');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `?page=game&id=${data.game_id}`;
        } else {
            showNotification('Failed to Create Game', data.error, 'error');
        }
    });
}

function createEnhancedGame(event) {
  event.preventDefault();

  // Define formData FIRST
  const formData = new FormData(event.target);
  const boardSize = parseInt(formData.get('board_size'));
  const playerCount = parseInt(formData.get('player_count'));
  const gameType = formData.get('game_type');

  if (gameType !== 'vs_ai') {
    const limits = BOARD_PLAYER_LIMITS[boardSize];
    if (limits && playerCount > limits.max) {
      showValidationError(`${limits.name} board supports maximum ${limits.max} players. Selected: ${playerCount} players.`);
      return;
    }
  }

  // Keep your original variable name
  const gameData = {
    action: 'create_game',
    room_name: formData.get('room_name') || `${playerCount}-Player Game`,
    player_count: formData.get('player_count'),
    board_size: formData.get('board_size'),
    ai_difficulty: formData.get('ai_difficulty') || 'medium',
    game_type: formData.get('game_type'),
    turn_timer: formData.get('turn_timer') || '30',
    skip_action: formData.get('skip_action') || 'skip_turn'
  };

  const btn = event.target.querySelector('button[type="submit"]');
  const txt = btn.textContent;
  btn.disabled = true; 
  btn.textContent = 'Creating...';

  fetch('', {
    method: 'POST',
    headers: {'Content-Type':'application/x-www-form-urlencoded'},
    body: new URLSearchParams(gameData)
  })
  .then(r => r.json())
  .then(data => {
    if (data.success) {
      window.location.href = `?page=game&id=${data.game_id}`;
    } else {
      showValidationError(data.error || 'Failed to create game');
    }
  })
  .catch(() => showValidationError('Network error: Could not connect to server'))
  .finally(() => { 
    btn.disabled = false; 
    btn.textContent = txt; 
  });
}



/*
function createEnhancedGame(event) {
    event.preventDefault();
    
// In createEnhancedGame function, update the payload object:

    const formData = new FormData(event.target);
    const gameData = {
        action: 'create_game',
    room_name: formData.get('room_name') || `${playerCount}-Player Game`,
//        room_name: formData.get('room_name'),
        game_type: formData.get('game_type'),
        player_count: formData.get('player_count'),
        board_size: formData.get('board_size'),
        turn_timer: formData.get('turn_timer') || '30',
        skip_action: formData.get('skip_action') || 'skip_turn',
        ai_difficulty: formData.get('ai_difficulty') || 'medium',
        enable_drops: formData.get('enable_drops') === 'on' ? 'true' : 'false'  // ADD THIS LINE

    };
    
    // Disable form during submission
    const submitBtn = event.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    submitBtn.disabled = true;
    submitBtn.textContent = 'Creating...';
    
    // Clear any existing errors
    const existingError = document.querySelector('.validation-error');
    if (existingError) {
        existingError.remove();
    }
    
    fetch('', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams(gameData)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Server response:', data);
        
        if (data.success) {
            // Redirect based on game type
                window.location.href = `?page=game&id=${data.game_id}`;
        } else {
            // Show server error
            showValidationError(data.error || 'Unknown server error');
            console.error('Server error details:', data);
        }
    })
    .catch(error => {
        console.error('Network error:', error);
        showValidationError('Network error: Could not connect to server');
    })
    .finally(() => {
        // Re-enable form
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
    });
}
*/

function showValidationError(message) {
    // Remove existing error
    const existingError = document.querySelector('.validation-error');
    if (existingError) {
        existingError.remove();
    }
    
    // Create error element
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error';
    errorDiv.style.cssText = `
        background: rgba(231, 76, 60, 0.2);
        border: 2px solid #e74c3c;
        border-radius: 8px;
        padding: 12px;
        margin: 10px 0;
        color: #fff;
        font-size: 14px;
        text-align: center;
        animation: errorShake 0.5s ease-in-out;
    `;
    errorDiv.textContent = message;
    
    // Insert before submit button
    const form = document.querySelector('form');
    const submitBtn = form.querySelector('button[type="submit"]');
    form.insertBefore(errorDiv, submitBtn);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (errorDiv.parentElement) {
            errorDiv.remove();
        }
    }, 5000);
}

// Game joining
function joinGame(gameId) {
    console.log('ğŸ® Joining game:', gameId);
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=join_game&game_id=${gameId}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `?page=game&id=${gameId}`;
        } else {
            showNotification('Failed to Join', data.error, 'error');
        }
    });
}

// Resign game functionality
function resignGame() {
    if (!confirm('âš ï¸ Are you sure you want to resign?\n\nThis will end the game and count as a loss for you. This action cannot be undone.')) {
        return;
    }
    
    console.log('ğŸ³ï¸ Resigning from game:', gameId);
    
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn) {
        resignBtn.disabled = true;
        resignBtn.textContent = 'ğŸ³ï¸ Resigning...';
    }
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=resign&game_id=${gameId}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('Game Resigned', data.message || 'You have resigned from the game', 'info');
        } else {
            showNotification('Resignation Failed', data.error, 'error');
            if (resignBtn) {
                resignBtn.disabled = false;
                resignBtn.textContent = 'ğŸ³ï¸ Resign Game';
            }
        }
    })
    .catch(error => {
        console.error('âŒ Resignation error:', error);
        showNotification('Connection Error', 'Unable to resign from game', 'error');
        if (resignBtn) {
            resignBtn.disabled = false;
            resignBtn.textContent = 'ğŸ³ï¸ Resign Game';
        }
    });
}

function loadAvailableGames() {
    console.log('ğŸ” Loading available games...');
    
    fetch(window.location.pathname + '?api=games')
        .then(response => {
            console.log('ğŸ“¡ Response status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(games => {
            console.log('âœ… Games loaded successfully:', games.length, 'games');
            
            const gameList = document.getElementById('available-games');
            if (!gameList) {
                console.error('âŒ gameList element not found');
                return;
            }
            
            if (games.length === 0) {
                gameList.innerHTML = '<p>No games available. Create one!</p>';
                return;
            }
            
            const gameHtml = games.map(game => `
                <div class="game-item">
                    <div class="game-info">
                        <h3>${game.game_name}</h3>
                        <p>${game.current_players}/${game.player_count} players</p>
                        <small>Created by ${game.creator}${game.player_names ? ' â€¢ Players: ' + game.player_names : ''}</small>
                    </div>
                    <button class="btn" onclick="joinGame('${game.game_id}')">Join</button>
                </div>
            `).join('');

            gameList.innerHTML = gameHtml;
            console.log('âœ… Game list updated in DOM');
        })
        .catch(error => {
            console.error('âŒ Error loading games:', error);
            const gameList = document.getElementById('available-games');
            if (gameList) {
                gameList.innerHTML = '<p>Error loading games. Check console.</p>';
            }
        });
}

// Load user's active games
function loadMyGames() {
    console.log('ğŸ¯ Loading my active games...');
    
    fetch(window.location.pathname + '?api=my-games')
        .then(response => {
            console.log('ğŸ“¡ My games response status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('ğŸ” DEBUG: Raw API response:', data);
            console.log('ğŸ” DEBUG: Type of data:', typeof data);
            console.log('ğŸ” DEBUG: Is array:', Array.isArray(data));

            if (data.error) {
                console.error('âŒ Error from server:', data.error);
                const gameList = document.getElementById('my-games');
                if (gameList) {
                    gameList.innerHTML = '<p>Error: ' + data.error + '</p>';
                }
                return;
            }
            
            const games = data;
            console.log('âœ… My games loaded successfully:', games.length, 'games');
            
            const gameList = document.getElementById('my-games');
            if (!gameList) {
                console.error('âŒ my-games element not found');
                return;
            }
            
            if (games.length === 0) {
                gameList.innerHTML = '<p>No active games. Join or create one!</p>';
                return;
            }
            
            const gameHtml = games.map(game => {
                let statusText = '';
                let buttonText = '';
                let buttonClass = 'btn';
                
                if (game.status === 'waiting') {
                    statusText = `Waiting for ${game.player_count - game.current_players} more player(s)`;
                    buttonText = 'Enter Waiting Room';
                } else if (game.status === 'active') {
                    statusText = game.is_your_turn ? 'Your turn!' : 'Waiting for other player';
                    buttonText = 'Resume Game';
                    buttonClass = game.is_your_turn ? 'btn' : 'btn btn-secondary';
                } else if (game.status === 'finished') {
                    statusText = game.winner_name ? `Won by ${game.winner_name}` : 'Game ended';
                    buttonText = 'View Game';
                    buttonClass = 'btn btn-secondary';
                }
                
                return `
                    <div class="game-item ${game.is_your_turn ? 'your-turn' : ''}">
                        <div class="game-info">
                            <h3>${game.game_name}</h3>
                            <p>${statusText}</p>
                            <small>${game.player_names || `${game.current_players}/${game.player_count} players`} â€¢ ${game.status}</small>
                        </div>
                        <button class="${buttonClass}" onclick="resumeGame('${game.game_id}')">${buttonText}</button>
                    </div>
                `;
            }).join('');

            gameList.innerHTML = gameHtml;
            console.log('âœ… My games list updated in DOM');
        })
        .catch(error => {
            console.error('âŒ Error loading my games:', error);
            const gameList = document.getElementById('my-games');
            if (gameList) {
                gameList.innerHTML = '<p>Error loading your games. Try refreshing.</p>';
            }
        });
}

// Resume/enter a game the user is already in
function resumeGame(gameId) {
    console.log('ğŸ® Resuming game:', gameId);
    window.location.href = `?page=game&id=${gameId}`;
}

function showNotification(title, message, type = 'error') {
    console.log(`ğŸ“¢ Notification: ${title} - ${message}`);
    
    const existing = document.querySelector('.notification');
    if (existing) existing.remove();
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 100);
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Game-specific JavaScript
function selectHex(q, r) {
    console.log('ğŸ¯ selectHex called:', q, r, 'gameId:', typeof gameId !== 'undefined' ? gameId : 'UNDEFINED');
    
    if (typeof userCanMove !== 'undefined' && !userCanMove) {
        showNotification('Not Your Turn', 'Wait for your turn to move', 'warning');
        return;
    }
    
    const cell = document.querySelector(`[data-q="${q}"][data-r="${r}"]`);
    if (!cell) {
        console.error('âŒ Cell not found for coordinates:', q, r);
        return;
    }
    
    // If clicking the same hex, deselect it
    if (selectedHex && selectedHex.q === q && selectedHex.r === r) {
        clearSelection();
        return;
    }
    
    // If we have a selected piece and clicked on a valid move, make the move
    if (selectedHex && cell.classList.contains('valid-move')) {
        makeMove(selectedHex.q, selectedHex.r, q, r);
        return;
    }
    
    // Check if there's actually a piece at this position
    const piece = cell.querySelector('.piece');
    if (!piece) {
        clearSelection();
        return; // No piece here, don't show any moves
    }
    
    // Select this piece and show its valid moves
    clearSelection();
    selectedHex = {q: q, r: r};
    cell.classList.add('selected');
    
    if (typeof gameId !== 'undefined' && gameId) {
        getValidMoves(q, r);
    } else {
        // For demo mode, highlight some example moves
        highlightValidMoves(q, r);
    }
}

function clearSelection() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        cell.classList.remove('selected', 'valid-move');
    });
    selectedHex = null;
}

function clearCheckHighlights() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        cell.classList.remove('king-in-check');
    });
}

function highlightValidMoves(q, r) {
    const directions = [
        [1, 0], [1, -1], [0, -1], [-1, 0], [-1, 1], [0, 1],
        [2, -1], [1, -2], [-1, -1], [-2, 1], [-1, 2], [1, 1]
    ];
    
    directions.forEach(([dq, dr]) => {
        const newQ = q + dq;
        const newR = r + dr;
        const targetCell = document.querySelector(`[data-q="${newQ}"][data-r="${newR}"]`);
        if (targetCell) {
            targetCell.classList.add('valid-move');
        }
    });
}

function getValidMoves(q, r) {
    console.log('ğŸ¯ Getting valid moves for:', q, r, 'gameId:', gameId);
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=getValidMoves&game_id=${gameId}&fromQ=${q}&fromR=${r}`
    })
    .then(response => response.json())
    .then(data => {
        console.log('ğŸ“¡ Server response:', data);
        
        if (data.success && data.validMoves && data.validMoves.length > 0) {
            console.log('âœ… Found', data.validMoves.length, 'valid moves');
            data.validMoves.forEach(move => {
                const targetCell = document.querySelector(`[data-q="${move.q}"][data-r="${move.r}"]`);
                if (targetCell) {
                    targetCell.classList.add('valid-move');
                }
            });
        } else {
            console.log('âŒ No valid moves or error:', data);
            clearSelection();
        }
    })
    .catch(error => {
        console.error('âŒ Fetch error:', error);
        clearSelection();
    });
}

function makeMove(fromQ, fromR, toQ, toR) {
    console.log('ğŸ¯ Making move:', fromQ, fromR, 'â†’', toQ, toR);
    
    // Check if game is over before making any move
    if (isGameOver()) {
        console.log('ğŸ Game is over, not making move');
        clearSelection();
        return;
    }
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=move&game_id=${gameId}&fromQ=${fromQ}&fromR=${fromR}&toQ=${toQ}&toR=${toR}`
    })
    .then(response => response.json())
    .then(data => {
        console.log('ğŸ“¡ Move response:', data);
        
        if (data.success) {
            console.log('âœ… Move successful');
            setTimeout(() => {
                location.reload();
            }, 500);
        } else {
            // Only show notifications for errors
            if (data.errorType === 'exposes-king') {
                showNotification('âš ï¸ King in Danger!', 'That move would expose your king to check', 'warning');
            } else if (data.errorType === 'wrong-player') {
                showNotification('âŒ Wrong Piece', 'You can only move your own pieces', 'error');
            } else if (data.errorType === 'no-piece') {
                showNotification('âŒ No Piece', 'No piece at selected position', 'error');
            } else {
                showNotification('âŒ Invalid Move', data.error || 'Move not allowed', 'error');
            }
        }
        clearSelection();
    })
    .catch(error => {
        console.error('âŒ Move error:', error);
        showNotification('âŒ Connection Error', 'Unable to make move', 'error');
        clearSelection();
    });
}

// Check if the game is over - enhanced detection
function isGameOver() {
    // If we already detected game over, stay that way
    if (gameOverDetected) {
        return true;
    }
    
    // Check for game over indicators in the page
    const gameStatus = document.getElementById('gameStatusText');
    if (gameStatus) {
        const statusText = gameStatus.textContent.toLowerCase();
        if (statusText.includes('game over') || 
            statusText.includes('checkmate') || 
            statusText.includes('stalemate') ||
            statusText.includes('wins') ||
            statusText.includes('resigned') ||
            statusText.includes('game ended') ||
            statusText.includes('victory') ||
            statusText.includes('defeat')) {
            console.log('ğŸ Game over detected from status text:', statusText);
            gameOverDetected = true;
            return true;
        }
    }
    
    // Check for game over elements
    const gameOverElements = document.querySelectorAll('[class*="game-over"], [class*="ended"], [class*="finished"], [class*="checkmate"], [class*="stalemate"]');
    if (gameOverElements.length > 0) {
        console.log('ğŸ Game over detected from elements');
        gameOverDetected = true;
        return true;
    }
    
    // Check if userCanMove is defined and game status indicates game over
    if (typeof userCanMove !== 'undefined' && typeof gameOver !== 'undefined' && gameOver) {
        console.log('ğŸ Game over detected from gameOver variable');
        gameOverDetected = true;
        return true;
    }
    
    // Check for resign button being hidden (might indicate game over)
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn && resignBtn.style.display === 'none') {
        console.log('ğŸ Game over detected from hidden resign button');
        gameOverDetected = true;
        return true;
    }
    
    return false;
}

// Enhanced game over detection and messaging
function checkAndHandleGameOver() {
    const gameStatus = document.getElementById('gameStatusText');
    if (!gameStatus) return false;
    
    const statusText = gameStatus.textContent.toLowerCase();
    
    // Detect different game over scenarios
    if (statusText.includes('checkmate')) {
        if (statusText.includes('red') || statusText.includes('you')) {
            showCheerfulGameOver('ğŸ‰ Checkmate! Red Wins! ğŸ‰', 'victory');
        } else if (statusText.includes('blue') || statusText.includes('ai')) {
            showCheerfulGameOver('ğŸ’™ Checkmate! Blue Wins! ğŸ’™', 'defeat');
        } else {
            showCheerfulGameOver('â™› Checkmate! Game Over! â™›', 'neutral');
        }
        return true;
    }
    
    if (statusText.includes('stalemate')) {
        showCheerfulGameOver('ğŸ¤ Stalemate! It\'s a Draw! ğŸ¤', 'draw');
        return true;
    }
    
    if (statusText.includes('resigned')) {
        if (statusText.includes('blue') || statusText.includes('ai')) {
            showCheerfulGameOver('ğŸ³ï¸ Blue Resigns! Red Wins! ğŸ‰', 'victory');
        } else {
            showCheerfulGameOver('ğŸ³ï¸ Red Resigns! Blue Wins! ğŸ’™', 'defeat');
        }
        return true;
    }
    
    if (statusText.includes('wins')) {
        if (statusText.includes('red')) {
            showCheerfulGameOver('ğŸ‰ Red Wins! Congratulations! ğŸ‰', 'victory');
        } else if (statusText.includes('blue')) {
            showCheerfulGameOver('ğŸ’™ Blue Wins! Well Played! ğŸ’™', 'defeat');
        } else {
            showCheerfulGameOver('ğŸ† Game Complete! ğŸ†', 'neutral');
        }
        return true;
    }
    
    return false;
}

// Show cheerful game over message
function showCheerfulGameOver(message, type) {
    console.log('ğŸŠ Game over:', message);
    
    // Update the game status with cheerful message
    const gameStatus = document.getElementById('gameStatusText');
    if (gameStatus) {
        gameStatus.innerHTML = `<div style="
            font-size: 18px; 
            font-weight: bold; 
            color: ${type === 'victory' ? '#4CAF50' : type === 'defeat' ? '#2196F3' : type === 'draw' ? '#FF9800' : '#333'};
            text-align: center;
            padding: 15px;
            background: ${type === 'victory' ? 'rgba(76, 175, 80, 0.1)' : type === 'defeat' ? 'rgba(33, 150, 243, 0.1)' : 'rgba(255, 152, 0, 0.1)'};
            border-radius: 8px;
            border: 2px solid ${type === 'victory' ? '#4CAF50' : type === 'defeat' ? '#2196F3' : type === 'draw' ? '#FF9800' : '#333'};
            margin: 10px 0;
        ">${message}</div>`;
    }
    
    // Hide resign button since game is over
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn) {
        resignBtn.style.display = 'none';
    }
    
    // Show a brief notification too
    showNotification('ğŸ Game Complete', message.replace(/[ğŸ‰ğŸ’™ğŸ¤ğŸ³ï¸ğŸŠğŸ†]/g, '').trim(), 
                    type === 'victory' ? 'success' : type === 'defeat' ? 'info' : 'warning');
}

function highlightKingsInCheck(kingsInCheck) {
    clearCheckHighlights();
    kingsInCheck.forEach(king => {
        const kingCell = document.querySelector(`[data-q="${king.q}"][data-r="${king.r}"]`);
        if (kingCell) {
            kingCell.classList.add('king-in-check');
        }
    });
}

function updateGameState(gameState) {
    if (gameState.gameStatus.gameOver) {
        console.log('ğŸ Game over detected in updateGameState');
        
        // Let the checkAndHandleGameOver function handle the messaging
        setTimeout(() => {
            checkAndHandleGameOver();
        }, 100);
        
        if (typeof userCanMove !== 'undefined') {
            userCanMove = false;
        }
        
        // Hide the resign button since game is over
        const resignBtn = document.querySelector('button[onclick="resignGame()"]');
        if (resignBtn) {
            resignBtn.style.display = 'none';
        }
    }
}

// DEMO FUNCTIONS
function showPiece(pieceType) {
    console.log('ğŸ­ showPiece called for:', pieceType);
    
    if (window.demoProcessing) {
        return;
    }
    
    window.demoProcessing = true;
    
    try {
        // Update UI
        document.querySelectorAll('.piece-nav-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        const navButton = document.getElementById(`nav-${pieceType}`);
        if (navButton) {
            navButton.classList.add('active');
        }
        
        document.querySelectorAll('.piece-desc').forEach(desc => {
            desc.classList.remove('active');
        });
        
        const descElement = document.getElementById(`desc-${pieceType}`);
        if (descElement) {
            descElement.classList.add('active');
        }
        
        // Clear highlights
        document.querySelectorAll('.hex-cell').forEach(cell => {
            cell.classList.remove('selected', 'valid-move', 'capture-square');
        });
        
        // Update piece and show pattern
        updateBoardPiece(pieceType);
        showMovementPattern(pieceType);
        
        console.log('âœ… Demo complete for:', pieceType);
        
    } catch (error) {
        console.error('âŒ Error:', error);
    } finally {
        setTimeout(() => {
            window.demoProcessing = false;
        }, 100);
    }
}

function updateBoardPiece(pieceType) {
    const pieceIcons = {
        'king': 'â™š', 
        'queen': 'â™›', 
        'rook': 'â™œ',
        'bishop': 'â™', 
        'knight': 'â™', 
        'pawn': 'â™Ÿ'
    };
    
    let demoQ, demoR;
    switch (pieceType) {
        case 'pawn':
            demoQ = -5; demoR = 0;
            break;
        default:
            demoQ = 0; demoR = 0;
    }
    
    // Clear all pieces first
    document.querySelectorAll('.hex-content').forEach(content => {
        content.innerHTML = '';
    });
    
    // Place new piece - ONLY add data-piece attribute, NO text content
    const pieceCell = document.querySelector(`[data-q="${demoQ}"][data-r="${demoR}"]`);
    if (pieceCell) {
        const pieceContent = pieceCell.querySelector('.hex-content');
        if (pieceContent) {
            // Create piece element with ONLY the data-piece attribute - let CSS handle the symbol
            pieceContent.innerHTML = `<span class='piece red-piece' data-piece='${pieceType}'></span>`;
        }
    }
}

function showMovementPattern(pieceType) {
    let demoQ, demoR;
    switch (pieceType) {
        case 'pawn':
            demoQ = -5; demoR = 0;
            break;
        default:
            demoQ = 0; demoR = 0;
    }
    
    // Highlight piece position
    const pieceCell = document.querySelector(`[data-q="${demoQ}"][data-r="${demoR}"]`);
    if (pieceCell) {
        pieceCell.classList.add('selected');
    }
    
    // Get moves and highlight them
    const validMoves = getValidMovesForPiece(pieceType, demoQ, demoR);
    
    console.log(`ğŸ¯ ${pieceType} valid moves:`, validMoves.length);
    
    validMoves.forEach(move => {
        const cell = document.querySelector(`[data-q="${move.q}"][data-r="${move.r}"]`);
        if (cell) {
            if (move.type === 'capture') {
                cell.classList.add('capture-square');
            } else {
                cell.classList.add('valid-move');
            }
        }
    });
}

function getValidMovesForPiece(pieceType, fromQ, fromR) {
    const moves = [];
    
    switch (pieceType) {
        case 'pawn':
            moves.push({q: fromQ + 1, r: fromR, type: 'move'});
            moves.push({q: fromQ + 1, r: fromR + 1, type: 'capture'});
            moves.push({q: fromQ + 2, r: fromR - 1, type: 'capture'});
            break;
            
        case 'bishop':
            const bishopDirections = [
                [1, 1], [-1, -1],
                [2, -1], [-2, 1],
                [1, -2], [-1, 2]
            ];
            
            bishopDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'queen':
            const queenDirections = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1],
                [1, 1], [-1, -1], [2, -1], [-2, 1], [1, -2], [-1, 2]
            ];
            
            queenDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'rook':
            const rookDirections = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]
            ];
            
            rookDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'knight':
            const knightMoves = [
                [2, 1], [3, -1], [1, 2], [-1, 3],
                [-2, 3], [-3, 2], [-3, 1], [-2, -1],
                [-1, -2], [1, -3], [2, -3], [3, -2]
            ];
            
            knightMoves.forEach(([dq, dr]) => {
                const newQ = fromQ + dq;
                const newR = fromR + dr;
                
                if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                    moves.push({q: newQ, r: newR, type: 'move'});
                }
            });
            break;
            
        case 'king':
            const kingMoves = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1],
                [1, 1], [-1, -1], [2, -1], [-2, 1], [1, -2], [-1, 2]
            ];
            
            kingMoves.forEach(([dq, dr]) => {
                const newQ = fromQ + dq;
                const newR = fromR + dr;
                
                if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                    moves.push({q: newQ, r: newR, type: 'move'});
                }
            });
            break;
    }
    
    return moves;
}

// Auto-load demo
function initializeDemoPage() {
    console.log('ğŸš€ Initializing demo page with king moves');
    
    setTimeout(() => {
        showPiece('king');
    }, 500);
}

// Function to apply hover effects to hex cells
function applyHoverEffects() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        // Remove any existing event listeners to prevent duplicates
        cell.removeEventListener('mouseenter', handlePieceHover);
        cell.removeEventListener('mouseleave', handlePieceLeave);
        
        // Add the hover event listeners
        cell.addEventListener('mouseenter', handlePieceHover);
        cell.addEventListener('mouseleave', handlePieceLeave);
    });
}

function handlePieceHover() {
    const piece = this.querySelector('.piece');
    if (piece) {
        // Combine centering AND scaling transforms
        piece.style.transform = 'translate(-50%, -50%) scale(1.15)';
        piece.style.transition = 'transform 0.2s ease';
    }
}

function handlePieceLeave() {
    const piece = this.querySelector('.piece');
    if (piece) {
        // Reset to just centering transform
        piece.style.transform = 'translate(-50%, -50%) scale(1)';
    }
}

// Helper functions
function isValidHex(q, r) {
    const BOARD_SIZE = 8;
    return Math.abs(q) <= BOARD_SIZE && 
           Math.abs(r) <= BOARD_SIZE && 
           Math.abs(q + r) <= BOARD_SIZE;
}

function getCellColor(q, r) {
    const colorIndex = ((q - r) % 3 + 3) % 3;
    const colors = ['pastel-red', 'pastel-green', 'pastel-blue'];
    return colors[colorIndex];
}

function showPieceDemo(pieceType) {
    showPiece(pieceType);
}

// Add CSS for error animation
const style = document.createElement('style');
style.textContent = `
@keyframes errorShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}
`;
document.head.appendChild(style);

// Add viewport meta tag if missing (helps with mobile rendering)
if (!document.querySelector('meta[name="viewport"]')) {
    const viewport = document.createElement('meta');
    viewport.name = 'viewport';
    viewport.content = 'width=device-width, initial-scale=1.0, user-scalable=no';
    document.head.appendChild(viewport);
}

// =============================================================================
// MAIN EVENT LISTENER - SINGLE DOMContentLoaded
// =============================================================================

document.addEventListener('DOMContentLoaded', function() {
    console.log('ğŸš€ Game.js initialized');
    
    // Simple check: only run enhanced room creation on lobby page
    if (!document.getElementById('game_type')) {
        console.log('â„¹ï¸ Not on lobby page, skipping enhanced room creation');
        
        document.addEventListener('DOMContentLoaded', function () {
  if (!document.getElementById('game_type')) {
    const root = document.getElementById('hexchess-root');
    if (root) {
      window.gameId = root.dataset.gameId || undefined;
      window.userCanMove = root.dataset.userCanMove === '1';
      window.gameMode = root.dataset.gameMode || 'multiplayer';
      window.isAIGame = (window.gameMode === 'ai');
      window.currentPlayerSlot = Number(root.dataset.currentPlayerSlot ?? 0);
      window.userPlayerSlot = Number(root.dataset.userPlayerSlot ?? -1);
      window.aiPlayerSlot = root.dataset.aiPlayerSlot === '' ? null : Number(root.dataset.aiPlayerSlot);

      // Hotseat should always be tappable on this device
      if (window.gameMode === 'hotseat') window.userCanMove = true;
    }
  }
});

        // Apply hover effects for game pages
        applyHoverEffects();
        
        // Demo page auto-init
        if (window.location.search.includes('page=demo')) {
            console.log('ğŸ“š Demo page detected, will auto-show king moves');
            initializeDemoPage();
        }
        
        // Check for game over state on page load
        setTimeout(() => {
            if (isGameOver()) {
                console.log('ğŸ Game over detected on page load');
                checkAndHandleGameOver();
            }
        }, 1000);
        
        return; // Exit early if not on lobby page
    }
    
    console.log('âœ“ Lobby page detected, setting up enhanced room creation...');
console.log('âœ“ Lobby page detected - letting index.php handle form events');

    // Continue with lobby-specific initialization
    if (document.getElementById('available-games')) {
        loadAvailableGames();
    }
    
    if (document.getElementById('my-games')) {
        loadMyGames();
    }
});

console.log('âœ… Complete game.js loaded successfully');