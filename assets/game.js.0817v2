console.log('üöÄ COMPLETE game.js loaded');

// Global variables
let selectedHex = null;
let gameOverDetected = false;

// Auth functions
function showAuth(type) {
    document.getElementById('loginForm').style.display = type === 'login' ? 'block' : 'none';
    document.getElementById('registerForm').style.display = type === 'register' ? 'block' : 'none';
}

function login(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'login');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            showNotification('Login Failed', data.error, 'error');
        }
    });
}

function register(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'register');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            showNotification('Registration Failed', data.error, 'error');
        }
    });
}

function logout() {
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'action=logout'
    })
    .then(() => location.reload());
}

// Game creation
function createGame(event) {
    event.preventDefault();
    const form = event.target;
    const formData = new FormData(form);
    formData.append('action', 'create_game');
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `?page=game&id=${data.game_id}`;
        } else {
            showNotification('Failed to Create Game', data.error, 'error');
        }
    });
}

// Enhanced game creation function
function createEnhancedGame(event) {
    event.preventDefault();
    
    const formData = new FormData(event.target);
    const gameData = {
        action: 'create_game',
        room_name: formData.get('room_name'),
        game_type: formData.get('game_type'),
        player_count: formData.get('player_count'),
        board_size: formData.get('board_size'),
        turn_timer: formData.get('turn_timer') || '30',
        skip_action: formData.get('skip_action') || 'skip_turn',
        ai_difficulty: formData.get('ai_difficulty') || 'medium'
    };
    
    // Disable form during submission
    const submitBtn = event.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    submitBtn.disabled = true;
    submitBtn.textContent = 'Creating...';
    
    // Clear any existing errors
    const existingError = document.querySelector('.validation-error');
    if (existingError) {
        existingError.remove();
    }
    
    fetch('', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams(gameData)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Server response:', data);
        
        if (data.success) {
            // Redirect based on game type
                window.location.href = `?page=game&id=${data.game_id}`;
        } else {
            // Show server error
            showValidationError(data.error || 'Unknown server error');
            console.error('Server error details:', data);
        }
    })
    .catch(error => {
        console.error('Network error:', error);
        showValidationError('Network error: Could not connect to server');
    })
    .finally(() => {
        // Re-enable form
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
    });
}

function showValidationError(message) {
    // Remove existing error
    const existingError = document.querySelector('.validation-error');
    if (existingError) {
        existingError.remove();
    }
    
    // Create error element
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error';
    errorDiv.style.cssText = `
        background: rgba(231, 76, 60, 0.2);
        border: 2px solid #e74c3c;
        border-radius: 8px;
        padding: 12px;
        margin: 10px 0;
        color: #fff;
        font-size: 14px;
        text-align: center;
        animation: errorShake 0.5s ease-in-out;
    `;
    errorDiv.textContent = message;
    
    // Insert before submit button
    const form = document.querySelector('form');
    const submitBtn = form.querySelector('button[type="submit"]');
    form.insertBefore(errorDiv, submitBtn);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (errorDiv.parentElement) {
            errorDiv.remove();
        }
    }, 5000);
}

// Game joining
function joinGame(gameId) {
    console.log('üéÆ Joining game:', gameId);
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=join_game&game_id=${gameId}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `?page=game&id=${gameId}`;
        } else {
            showNotification('Failed to Join', data.error, 'error');
        }
    });
}

// Resign game functionality
function resignGame() {
    if (!confirm('‚ö†Ô∏è Are you sure you want to resign?\n\nThis will end the game and count as a loss for you. This action cannot be undone.')) {
        return;
    }
    
    console.log('üè≥Ô∏è Resigning from game:', gameId);
    
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn) {
        resignBtn.disabled = true;
        resignBtn.textContent = 'üè≥Ô∏è Resigning...';
    }
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=resign&game_id=${gameId}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('Game Resigned', data.message || 'You have resigned from the game', 'info');
        } else {
            showNotification('Resignation Failed', data.error, 'error');
            if (resignBtn) {
                resignBtn.disabled = false;
                resignBtn.textContent = 'üè≥Ô∏è Resign Game';
            }
        }
    })
    .catch(error => {
        console.error('‚ùå Resignation error:', error);
        showNotification('Connection Error', 'Unable to resign from game', 'error');
        if (resignBtn) {
            resignBtn.disabled = false;
            resignBtn.textContent = 'üè≥Ô∏è Resign Game';
        }
    });
}

function loadAvailableGames() {
    console.log('üîç Loading available games...');
    
    fetch(window.location.pathname + '?api=games')
        .then(response => {
            console.log('üì° Response status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(games => {
            console.log('‚úÖ Games loaded successfully:', games.length, 'games');
            
            const gameList = document.getElementById('available-games');
            if (!gameList) {
                console.error('‚ùå gameList element not found');
                return;
            }
            
            if (games.length === 0) {
                gameList.innerHTML = '<p>No games available. Create one!</p>';
                return;
            }
            
            const gameHtml = games.map(game => `
                <div class="game-item">
                    <div class="game-info">
                        <h3>${game.game_name}</h3>
                        <p>${game.current_players}/${game.player_count} players</p>
                        <small>Created by ${game.creator}${game.player_names ? ' ‚Ä¢ Players: ' + game.player_names : ''}</small>
                    </div>
                    <button class="btn" onclick="joinGame('${game.game_id}')">Join</button>
                </div>
            `).join('');

            gameList.innerHTML = gameHtml;
            console.log('‚úÖ Game list updated in DOM');
        })
        .catch(error => {
            console.error('‚ùå Error loading games:', error);
            const gameList = document.getElementById('available-games');
            if (gameList) {
                gameList.innerHTML = '<p>Error loading games. Check console.</p>';
            }
        });
}

// Load user's active games
function loadMyGames() {
    console.log('üéØ Loading my active games...');
    
    fetch(window.location.pathname + '?api=my-games')
        .then(response => {
            console.log('üì° My games response status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('üîç DEBUG: Raw API response:', data);
            console.log('üîç DEBUG: Type of data:', typeof data);
            console.log('üîç DEBUG: Is array:', Array.isArray(data));

            if (data.error) {
                console.error('‚ùå Error from server:', data.error);
                const gameList = document.getElementById('my-games');
                if (gameList) {
                    gameList.innerHTML = '<p>Error: ' + data.error + '</p>';
                }
                return;
            }
            
            const games = data;
            console.log('‚úÖ My games loaded successfully:', games.length, 'games');
            
            const gameList = document.getElementById('my-games');
            if (!gameList) {
                console.error('‚ùå my-games element not found');
                return;
            }
            
            if (games.length === 0) {
                gameList.innerHTML = '<p>No active games. Join or create one!</p>';
                return;
            }
            
            const gameHtml = games.map(game => {
                let statusText = '';
                let buttonText = '';
                let buttonClass = 'btn';
                
                if (game.status === 'waiting') {
                    statusText = `Waiting for ${game.player_count - game.current_players} more player(s)`;
                    buttonText = 'Enter Waiting Room';
                } else if (game.status === 'active') {
                    statusText = game.is_your_turn ? 'Your turn!' : 'Waiting for other player';
                    buttonText = 'Resume Game';
                    buttonClass = game.is_your_turn ? 'btn' : 'btn btn-secondary';
                } else if (game.status === 'finished') {
                    statusText = game.winner_name ? `Won by ${game.winner_name}` : 'Game ended';
                    buttonText = 'View Game';
                    buttonClass = 'btn btn-secondary';
                }
                
                return `
                    <div class="game-item ${game.is_your_turn ? 'your-turn' : ''}">
                        <div class="game-info">
                            <h3>${game.game_name}</h3>
                            <p>${statusText}</p>
                            <small>${game.player_names || `${game.current_players}/${game.player_count} players`} ‚Ä¢ ${game.status}</small>
                        </div>
                        <button class="${buttonClass}" onclick="resumeGame('${game.game_id}')">${buttonText}</button>
                    </div>
                `;
            }).join('');

            gameList.innerHTML = gameHtml;
            console.log('‚úÖ My games list updated in DOM');
        })
        .catch(error => {
            console.error('‚ùå Error loading my games:', error);
            const gameList = document.getElementById('my-games');
            if (gameList) {
                gameList.innerHTML = '<p>Error loading your games. Try refreshing.</p>';
            }
        });
}

// Resume/enter a game the user is already in
function resumeGame(gameId) {
    console.log('üéÆ Resuming game:', gameId);
    window.location.href = `?page=game&id=${gameId}`;
}

function showNotification(title, message, type = 'error') {
    console.log(`üì¢ Notification: ${title} - ${message}`);
    
    const existing = document.querySelector('.notification');
    if (existing) existing.remove();
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 100);
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Game-specific JavaScript
function selectHex(q, r) {
    console.log('üéØ selectHex called:', q, r, 'gameId:', typeof gameId !== 'undefined' ? gameId : 'UNDEFINED');
    
    if (typeof userCanMove !== 'undefined' && !userCanMove) {
        showNotification('Not Your Turn', 'Wait for your turn to move', 'warning');
        return;
    }
    
    const cell = document.querySelector(`[data-q="${q}"][data-r="${r}"]`);
    if (!cell) {
        console.error('‚ùå Cell not found for coordinates:', q, r);
        return;
    }
    
    // If clicking the same hex, deselect it
    if (selectedHex && selectedHex.q === q && selectedHex.r === r) {
        clearSelection();
        return;
    }
    
    // If we have a selected piece and clicked on a valid move, make the move
    if (selectedHex && cell.classList.contains('valid-move')) {
        makeMove(selectedHex.q, selectedHex.r, q, r);
        return;
    }
    
    // Check if there's actually a piece at this position
    const piece = cell.querySelector('.piece');
    if (!piece) {
        clearSelection();
        return; // No piece here, don't show any moves
    }
    
    // Select this piece and show its valid moves
    clearSelection();
    selectedHex = {q: q, r: r};
    cell.classList.add('selected');
    
    if (typeof gameId !== 'undefined' && gameId) {
        getValidMoves(q, r);
    } else {
        // For demo mode, highlight some example moves
        highlightValidMoves(q, r);
    }
}

function clearSelection() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        cell.classList.remove('selected', 'valid-move');
    });
    selectedHex = null;
}

function clearCheckHighlights() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        cell.classList.remove('king-in-check');
    });
}

function highlightValidMoves(q, r) {
    const directions = [
        [1, 0], [1, -1], [0, -1], [-1, 0], [-1, 1], [0, 1],
        [2, -1], [1, -2], [-1, -1], [-2, 1], [-1, 2], [1, 1]
    ];
    
    directions.forEach(([dq, dr]) => {
        const newQ = q + dq;
        const newR = r + dr;
        const targetCell = document.querySelector(`[data-q="${newQ}"][data-r="${newR}"]`);
        if (targetCell) {
            targetCell.classList.add('valid-move');
        }
    });
}

function getValidMoves(q, r) {
    console.log('üéØ Getting valid moves for:', q, r, 'gameId:', gameId);
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=getValidMoves&game_id=${gameId}&fromQ=${q}&fromR=${r}`
    })
    .then(response => response.json())
    .then(data => {
        console.log('üì° Server response:', data);
        
        if (data.success && data.validMoves && data.validMoves.length > 0) {
            console.log('‚úÖ Found', data.validMoves.length, 'valid moves');
            data.validMoves.forEach(move => {
                const targetCell = document.querySelector(`[data-q="${move.q}"][data-r="${move.r}"]`);
                if (targetCell) {
                    targetCell.classList.add('valid-move');
                }
            });
        } else {
            console.log('‚ùå No valid moves or error:', data);
            clearSelection();
        }
    })
    .catch(error => {
        console.error('‚ùå Fetch error:', error);
        clearSelection();
    });
}

function makeMove(fromQ, fromR, toQ, toR) {
    console.log('üéØ Making move:', fromQ, fromR, '‚Üí', toQ, toR);
    
    // Check if game is over before making any move
    if (isGameOver()) {
        console.log('üèÅ Game is over, not making move');
        clearSelection();
        return;
    }
    
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `action=move&game_id=${gameId}&fromQ=${fromQ}&fromR=${fromR}&toQ=${toQ}&toR=${toR}`
    })
    .then(response => response.json())
    .then(data => {
        console.log('üì° Move response:', data);
        
        if (data.success) {
            console.log('‚úÖ Move successful');
            setTimeout(() => {
                location.reload();
            }, 500);
        } else {
            // Only show notifications for errors
            if (data.errorType === 'exposes-king') {
                showNotification('‚ö†Ô∏è King in Danger!', 'That move would expose your king to check', 'warning');
            } else if (data.errorType === 'wrong-player') {
                showNotification('‚ùå Wrong Piece', 'You can only move your own pieces', 'error');
            } else if (data.errorType === 'no-piece') {
                showNotification('‚ùå No Piece', 'No piece at selected position', 'error');
            } else {
                showNotification('‚ùå Invalid Move', data.error || 'Move not allowed', 'error');
            }
        }
        clearSelection();
    })
    .catch(error => {
        console.error('‚ùå Move error:', error);
        showNotification('‚ùå Connection Error', 'Unable to make move', 'error');
        clearSelection();
    });
}

// Check if the game is over - enhanced detection
function isGameOver() {
    // If we already detected game over, stay that way
    if (gameOverDetected) {
        return true;
    }
    
    // Check for game over indicators in the page
    const gameStatus = document.getElementById('gameStatusText');
    if (gameStatus) {
        const statusText = gameStatus.textContent.toLowerCase();
        if (statusText.includes('game over') || 
            statusText.includes('checkmate') || 
            statusText.includes('stalemate') ||
            statusText.includes('wins') ||
            statusText.includes('resigned') ||
            statusText.includes('game ended') ||
            statusText.includes('victory') ||
            statusText.includes('defeat')) {
            console.log('üèÅ Game over detected from status text:', statusText);
            gameOverDetected = true;
            return true;
        }
    }
    
    // Check for game over elements
    const gameOverElements = document.querySelectorAll('[class*="game-over"], [class*="ended"], [class*="finished"], [class*="checkmate"], [class*="stalemate"]');
    if (gameOverElements.length > 0) {
        console.log('üèÅ Game over detected from elements');
        gameOverDetected = true;
        return true;
    }
    
    // Check if userCanMove is defined and game status indicates game over
    if (typeof userCanMove !== 'undefined' && typeof gameOver !== 'undefined' && gameOver) {
        console.log('üèÅ Game over detected from gameOver variable');
        gameOverDetected = true;
        return true;
    }
    
    // Check for resign button being hidden (might indicate game over)
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn && resignBtn.style.display === 'none') {
        console.log('üèÅ Game over detected from hidden resign button');
        gameOverDetected = true;
        return true;
    }
    
    return false;
}

// Enhanced game over detection and messaging
function checkAndHandleGameOver() {
    const gameStatus = document.getElementById('gameStatusText');
    if (!gameStatus) return false;
    
    const statusText = gameStatus.textContent.toLowerCase();
    
    // Detect different game over scenarios
    if (statusText.includes('checkmate')) {
        if (statusText.includes('red') || statusText.includes('you')) {
            showCheerfulGameOver('üéâ Checkmate! Red Wins! üéâ', 'victory');
        } else if (statusText.includes('blue') || statusText.includes('ai')) {
            showCheerfulGameOver('üíô Checkmate! Blue Wins! üíô', 'defeat');
        } else {
            showCheerfulGameOver('‚ôõ Checkmate! Game Over! ‚ôõ', 'neutral');
        }
        return true;
    }
    
    if (statusText.includes('stalemate')) {
        showCheerfulGameOver('ü§ù Stalemate! It\'s a Draw! ü§ù', 'draw');
        return true;
    }
    
    if (statusText.includes('resigned')) {
        if (statusText.includes('blue') || statusText.includes('ai')) {
            showCheerfulGameOver('üè≥Ô∏è Blue Resigns! Red Wins! üéâ', 'victory');
        } else {
            showCheerfulGameOver('üè≥Ô∏è Red Resigns! Blue Wins! üíô', 'defeat');
        }
        return true;
    }
    
    if (statusText.includes('wins')) {
        if (statusText.includes('red')) {
            showCheerfulGameOver('üéâ Red Wins! Congratulations! üéâ', 'victory');
        } else if (statusText.includes('blue')) {
            showCheerfulGameOver('üíô Blue Wins! Well Played! üíô', 'defeat');
        } else {
            showCheerfulGameOver('üèÜ Game Complete! üèÜ', 'neutral');
        }
        return true;
    }
    
    return false;
}

// Show cheerful game over message
function showCheerfulGameOver(message, type) {
    console.log('üéä Game over:', message);
    
    // Update the game status with cheerful message
    const gameStatus = document.getElementById('gameStatusText');
    if (gameStatus) {
        gameStatus.innerHTML = `<div style="
            font-size: 18px; 
            font-weight: bold; 
            color: ${type === 'victory' ? '#4CAF50' : type === 'defeat' ? '#2196F3' : type === 'draw' ? '#FF9800' : '#333'};
            text-align: center;
            padding: 15px;
            background: ${type === 'victory' ? 'rgba(76, 175, 80, 0.1)' : type === 'defeat' ? 'rgba(33, 150, 243, 0.1)' : 'rgba(255, 152, 0, 0.1)'};
            border-radius: 8px;
            border: 2px solid ${type === 'victory' ? '#4CAF50' : type === 'defeat' ? '#2196F3' : type === 'draw' ? '#FF9800' : '#333'};
            margin: 10px 0;
        ">${message}</div>`;
    }
    
    // Hide resign button since game is over
    const resignBtn = document.querySelector('button[onclick="resignGame()"]');
    if (resignBtn) {
        resignBtn.style.display = 'none';
    }
    
    // Show a brief notification too
    showNotification('üèÅ Game Complete', message.replace(/[üéâüíôü§ùüè≥Ô∏èüéäüèÜ]/g, '').trim(), 
                    type === 'victory' ? 'success' : type === 'defeat' ? 'info' : 'warning');
}

function highlightKingsInCheck(kingsInCheck) {
    clearCheckHighlights();
    kingsInCheck.forEach(king => {
        const kingCell = document.querySelector(`[data-q="${king.q}"][data-r="${king.r}"]`);
        if (kingCell) {
            kingCell.classList.add('king-in-check');
        }
    });
}

function updateGameState(gameState) {
    if (gameState.gameStatus.gameOver) {
        console.log('üèÅ Game over detected in updateGameState');
        
        // Let the checkAndHandleGameOver function handle the messaging
        setTimeout(() => {
            checkAndHandleGameOver();
        }, 100);
        
        if (typeof userCanMove !== 'undefined') {
            userCanMove = false;
        }
        
        // Hide the resign button since game is over
        const resignBtn = document.querySelector('button[onclick="resignGame()"]');
        if (resignBtn) {
            resignBtn.style.display = 'none';
        }
    }
}

// DEMO FUNCTIONS
function showPiece(pieceType) {
    console.log('üé≠ showPiece called for:', pieceType);
    
    if (window.demoProcessing) {
        return;
    }
    
    window.demoProcessing = true;
    
    try {
        // Update UI
        document.querySelectorAll('.piece-nav-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        const navButton = document.getElementById(`nav-${pieceType}`);
        if (navButton) {
            navButton.classList.add('active');
        }
        
        document.querySelectorAll('.piece-desc').forEach(desc => {
            desc.classList.remove('active');
        });
        
        const descElement = document.getElementById(`desc-${pieceType}`);
        if (descElement) {
            descElement.classList.add('active');
        }
        
        // Clear highlights
        document.querySelectorAll('.hex-cell').forEach(cell => {
            cell.classList.remove('selected', 'valid-move', 'capture-square');
        });
        
        // Update piece and show pattern
        updateBoardPiece(pieceType);
        showMovementPattern(pieceType);
        
        console.log('‚úÖ Demo complete for:', pieceType);
        
    } catch (error) {
        console.error('‚ùå Error:', error);
    } finally {
        setTimeout(() => {
            window.demoProcessing = false;
        }, 100);
    }
}

function updateBoardPiece(pieceType) {
    const pieceIcons = {
        'king': '‚ôö', 
        'queen': '‚ôõ', 
        'rook': '‚ôú',
        'bishop': '‚ôù', 
        'knight': '‚ôû', 
        'pawn': '‚ôü'
    };
    
    let demoQ, demoR;
    switch (pieceType) {
        case 'pawn':
            demoQ = -5; demoR = 0;
            break;
        default:
            demoQ = 0; demoR = 0;
    }
    
    // Clear all pieces first
    document.querySelectorAll('.hex-content').forEach(content => {
        content.innerHTML = '';
    });
    
    // Place new piece - ONLY add data-piece attribute, NO text content
    const pieceCell = document.querySelector(`[data-q="${demoQ}"][data-r="${demoR}"]`);
    if (pieceCell) {
        const pieceContent = pieceCell.querySelector('.hex-content');
        if (pieceContent) {
            // Create piece element with ONLY the data-piece attribute - let CSS handle the symbol
            pieceContent.innerHTML = `<span class='piece red-piece' data-piece='${pieceType}'></span>`;
        }
    }
}

function showMovementPattern(pieceType) {
    let demoQ, demoR;
    switch (pieceType) {
        case 'pawn':
            demoQ = -5; demoR = 0;
            break;
        default:
            demoQ = 0; demoR = 0;
    }
    
    // Highlight piece position
    const pieceCell = document.querySelector(`[data-q="${demoQ}"][data-r="${demoR}"]`);
    if (pieceCell) {
        pieceCell.classList.add('selected');
    }
    
    // Get moves and highlight them
    const validMoves = getValidMovesForPiece(pieceType, demoQ, demoR);
    
    console.log(`üéØ ${pieceType} valid moves:`, validMoves.length);
    
    validMoves.forEach(move => {
        const cell = document.querySelector(`[data-q="${move.q}"][data-r="${move.r}"]`);
        if (cell) {
            if (move.type === 'capture') {
                cell.classList.add('capture-square');
            } else {
                cell.classList.add('valid-move');
            }
        }
    });
}

function getValidMovesForPiece(pieceType, fromQ, fromR) {
    const moves = [];
    
    switch (pieceType) {
        case 'pawn':
            moves.push({q: fromQ + 1, r: fromR, type: 'move'});
            moves.push({q: fromQ + 1, r: fromR + 1, type: 'capture'});
            moves.push({q: fromQ + 2, r: fromR - 1, type: 'capture'});
            break;
            
        case 'bishop':
            const bishopDirections = [
                [1, 1], [-1, -1],
                [2, -1], [-2, 1],
                [1, -2], [-1, 2]
            ];
            
            bishopDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'queen':
            const queenDirections = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1],
                [1, 1], [-1, -1], [2, -1], [-2, 1], [1, -2], [-1, 2]
            ];
            
            queenDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'rook':
            const rookDirections = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]
            ];
            
            rookDirections.forEach(([dq, dr]) => {
                for (let step = 1; step <= 8; step++) {
                    const newQ = fromQ + dq * step;
                    const newR = fromR + dr * step;
                    
                    if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                        moves.push({q: newQ, r: newR, type: 'move'});
                    } else {
                        break;
                    }
                }
            });
            break;
            
        case 'knight':
            const knightMoves = [
                [2, 1], [3, -1], [1, 2], [-1, 3],
                [-2, 3], [-3, 2], [-3, 1], [-2, -1],
                [-1, -2], [1, -3], [2, -3], [3, -2]
            ];
            
            knightMoves.forEach(([dq, dr]) => {
                const newQ = fromQ + dq;
                const newR = fromR + dr;
                
                if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                    moves.push({q: newQ, r: newR, type: 'move'});
                }
            });
            break;
            
        case 'king':
            const kingMoves = [
                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1],
                [1, 1], [-1, -1], [2, -1], [-2, 1], [1, -2], [-1, 2]
            ];
            
            kingMoves.forEach(([dq, dr]) => {
                const newQ = fromQ + dq;
                const newR = fromR + dr;
                
                if (Math.abs(newQ) <= 8 && Math.abs(newR) <= 8 && Math.abs(newQ + newR) <= 8) {
                    moves.push({q: newQ, r: newR, type: 'move'});
                }
            });
            break;
    }
    
    return moves;
}

// Auto-load demo
function initializeDemoPage() {
    console.log('üöÄ Initializing demo page with king moves');
    
    setTimeout(() => {
        showPiece('king');
    }, 500);
}

// Function to apply hover effects to hex cells
function applyHoverEffects() {
    document.querySelectorAll('.hex-cell').forEach(cell => {
        // Remove any existing event listeners to prevent duplicates
        cell.removeEventListener('mouseenter', handlePieceHover);
        cell.removeEventListener('mouseleave', handlePieceLeave);
        
        // Add the hover event listeners
        cell.addEventListener('mouseenter', handlePieceHover);
        cell.addEventListener('mouseleave', handlePieceLeave);
    });
}

function handlePieceHover() {
    const piece = this.querySelector('.piece');
    if (piece) {
        // Combine centering AND scaling transforms
        piece.style.transform = 'translate(-50%, -50%) scale(1.15)';
        piece.style.transition = 'transform 0.2s ease';
    }
}

function handlePieceLeave() {
    const piece = this.querySelector('.piece');
    if (piece) {
        // Reset to just centering transform
        piece.style.transform = 'translate(-50%, -50%) scale(1)';
    }
}

// Helper functions
function isValidHex(q, r) {
    const BOARD_SIZE = 8;
    return Math.abs(q) <= BOARD_SIZE && 
           Math.abs(r) <= BOARD_SIZE && 
           Math.abs(q + r) <= BOARD_SIZE;
}

function getCellColor(q, r) {
    const colorIndex = ((q - r) % 3 + 3) % 3;
    const colors = ['pastel-red', 'pastel-green', 'pastel-blue'];
    return colors[colorIndex];
}

function showPieceDemo(pieceType) {
    showPiece(pieceType);
}

// Add CSS for error animation
const style = document.createElement('style');
style.textContent = `
@keyframes errorShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}
`;
document.head.appendChild(style);

// Add viewport meta tag if missing (helps with mobile rendering)
if (!document.querySelector('meta[name="viewport"]')) {
    const viewport = document.createElement('meta');
    viewport.name = 'viewport';
    viewport.content = 'width=device-width, initial-scale=1.0, user-scalable=no';
    document.head.appendChild(viewport);
}

// =============================================================================
// MAIN EVENT LISTENER - SINGLE DOMContentLoaded
// =============================================================================

document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Game.js initialized');
    
    // Simple check: only run enhanced room creation on lobby page
    if (!document.getElementById('game_type')) {
        console.log('‚ÑπÔ∏è Not on lobby page, skipping enhanced room creation');
        
        document.addEventListener('DOMContentLoaded', function () {
  if (!document.getElementById('game_type')) {
    const root = document.getElementById('hexchess-root');
    if (root) {
      window.gameId = root.dataset.gameId || undefined;
      window.userCanMove = root.dataset.userCanMove === '1';
      window.gameMode = root.dataset.gameMode || 'multiplayer';
      window.isAIGame = (window.gameMode === 'ai');
      window.currentPlayerSlot = Number(root.dataset.currentPlayerSlot ?? 0);
      window.userPlayerSlot = Number(root.dataset.userPlayerSlot ?? -1);
      window.aiPlayerSlot = root.dataset.aiPlayerSlot === '' ? null : Number(root.dataset.aiPlayerSlot);

      // Hotseat should always be tappable on this device
      if (window.gameMode === 'hotseat') window.userCanMove = true;
    }
  }
});

        // Apply hover effects for game pages
        applyHoverEffects();
        
        // Demo page auto-init
        if (window.location.search.includes('page=demo')) {
            console.log('üìö Demo page detected, will auto-show king moves');
            initializeDemoPage();
        }
        
        // Check for game over state on page load
        setTimeout(() => {
            if (isGameOver()) {
                console.log('üèÅ Game over detected on page load');
                checkAndHandleGameOver();
            }
        }, 1000);
        
        return; // Exit early if not on lobby page
    }
    
    console.log('‚úì Lobby page detected, setting up enhanced room creation...');
    
    // BOARD_PLAYER_LIMITS - only define on lobby page
    const BOARD_PLAYER_LIMITS = {
  5: { min: 2, max: 3, name: "Small" },
  6: { min: 2, max: 4, name: "Medium" },
  7: { min: 2, max: 6, name: "Large" },
  8: { min: 2, max: 6, name: "Jumbo" }
};

    
    // Enhanced room creation functions - only run on lobby page
    function updateEnhancedGameModeOptions() {
        const gameType = document.getElementById('game_type');
        const playersGroup = document.getElementById('players-group');
        const aiDifficultyGroup = document.getElementById('ai-difficulty-group');
        const playerCount = document.getElementById('player_count');
        
        if (!gameType || !playersGroup || !aiDifficultyGroup || !playerCount) {
            return; // Safety check
        }
        
        const gameTypeValue = gameType.value;
        
        // Clear validation errors
        const existingError = document.querySelector('.validation-error');
        if (existingError) existingError.remove();
        
        // Show/hide AI difficulty
        if (gameTypeValue === 'vs_ai') {
            aiDifficultyGroup.style.display = 'block';
            playerCount.innerHTML = '<option value="2">2 Players</option>';
            playerCount.value = '2';
            playersGroup.style.display = 'none';
        } else {
            aiDifficultyGroup.style.display = 'none';
            playersGroup.style.display = 'block';
            updatePlayerOptions();
        }
        
        updateTimerVisibility();
        updateEnhancedDefaultGameName();
    }
    
    function updatePlayerOptions() {
        const boardSizeSelect = document.getElementById('board_size');
        const playerCountSelect = document.getElementById('player_count');
        const gameTypeSelect = document.getElementById('game_type');
        
        if (!boardSizeSelect || !playerCountSelect || !gameTypeSelect) return;
        
        const boardSize = parseInt(boardSizeSelect.value);
        const gameType = gameTypeSelect.value;
        
        if (gameType === 'vs_ai') return;
        
        const limits = BOARD_PLAYER_LIMITS[boardSize];
        if (!limits) return;
        
        const currentValue = parseInt(playerCountSelect.value);
        playerCountSelect.innerHTML = '';
        
        for (let i = limits.min; i <= limits.max; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `${i} Players`;
            playerCountSelect.appendChild(option);
        }
        
        if (currentValue >= limits.min && currentValue <= limits.max) {
            playerCountSelect.value = currentValue;
        } else {
            playerCountSelect.value = limits.min;
        }
        
        updateTimerVisibility();
        updateEnhancedDefaultGameName();
    }
    
    function updateTimerVisibility() {
        const playerCountSelect = document.getElementById('player_count');
        const timerSettings = document.getElementById('timer-settings');
        
        if (!playerCountSelect || !timerSettings) return;
        
        const playerCount = parseInt(playerCountSelect.value);
        
        if (playerCount >= 4) {
            timerSettings.style.display = 'block';
        } else {
            timerSettings.style.display = 'none';
        }
    }
    
    function updateEnhancedDefaultGameName() {
        console.log('üîÑ updateEnhancedDefaultGameName called');
        
        const gameTypeSelect = document.getElementById('game_type');
        const playerCountSelect = document.getElementById('player_count');
        const boardSizeSelect = document.getElementById('board_size');
        const aiDifficultySelect = document.getElementById('ai_difficulty');
        const gameNameField = document.getElementById('game_name');
        
        if (!gameTypeSelect || !playerCountSelect || !boardSizeSelect || !gameNameField) {
            console.log('‚ùå Missing form elements for room name update');
            return;
        }
        
        const gameType = gameTypeSelect.value;
        const playerCount = playerCountSelect.value;
        const boardSize = boardSizeSelect.value;
        const aiDifficulty = aiDifficultySelect ? aiDifficultySelect.value : 'medium';
        
        console.log('üîÑ Form values:', {gameType, playerCount, boardSize, aiDifficulty});
        
        let gameTypeName = '';
        switch (gameType) {
            case 'online': gameTypeName = 'Online'; break;
            case 'vs_ai': gameTypeName = 'vs AI'; break;
            case 'hotseat': gameTypeName = 'Hotseat'; break;
        }
        
        let sizeName = '';
        switch (boardSize) {
            case '5': sizeName = 'Small'; break;
            case '6': sizeName = 'Medium'; break;
            case '7': sizeName = 'Large'; break;
            case '8': sizeName = 'Jumbo'; break;
        }
        
        let defaultName = '';
        if (gameType === 'vs_ai') {
            const difficultyName = aiDifficulty.charAt(0).toUpperCase() + aiDifficulty.slice(1);
            defaultName = `${difficultyName} AI ${sizeName}`;
        } else {
            defaultName = `${gameTypeName} ${playerCount}P ${sizeName}`;
        }
        
        const currentValue = gameNameField.value.trim();
        const isDefaultName = currentValue === '' || 
                             currentValue.match(/^(Online|vs AI|Hotseat|\w+ AI).*(Small|Medium|Large|Jumbo).*$/);
        
        console.log('üîÑ Calculated room name:', defaultName);
        console.log('üîÑ Current value:', currentValue);
        console.log('üîÑ Should update:', isDefaultName);
        
        if (isDefaultName) {
            gameNameField.value = defaultName;
            console.log('‚úÖ Room name updated to:', defaultName);
        } else {
            console.log('‚ÑπÔ∏è Room name not updated (user has custom name)');
        }
    }
    
    function resetToEnhancedDefaultName() {
        const gameNameField = document.getElementById('game_name');
        if (!gameNameField) return;
        
        gameNameField.value = '';
        updateEnhancedDefaultGameName();
    }
    
    // Make ALL functions available globally (for HTML onchange attributes)
    window.updateEnhancedGameModeOptions = updateEnhancedGameModeOptions;
    window.updatePlayerOptions = updatePlayerOptions;
    window.updateTimerVisibility = updateTimerVisibility;
    window.updateEnhancedDefaultGameName = updateEnhancedDefaultGameName;
    window.resetToEnhancedDefaultName = resetToEnhancedDefaultName;
    
    // Set up event listeners - only on lobby page
    const gameTypeSelect = document.getElementById('game_type');
    const playerCountSelect = document.getElementById('player_count');
    const boardSizeSelect = document.getElementById('board_size');
    const aiDifficultySelect = document.getElementById('ai_difficulty');
    
    if (gameTypeSelect) {
        // Remove any existing onchange to prevent conflicts
        gameTypeSelect.onchange = null;
        gameTypeSelect.addEventListener('change', updateEnhancedGameModeOptions);
        console.log('‚úì Game type listener attached');
    }
    
    if (playerCountSelect) {
        playerCountSelect.onchange = null;
        playerCountSelect.addEventListener('change', function() {
            console.log('üîÑ Player count changed to:', this.value);
            updateTimerVisibility();
            updateEnhancedDefaultGameName();
            const existingError = document.querySelector('.validation-error');
            if (existingError) existingError.remove();
        });
        console.log('‚úì Player count listener attached');
    }
    
    if (boardSizeSelect) {
        boardSizeSelect.onchange = null;
        boardSizeSelect.addEventListener('change', function() {
            console.log('üîÑ Board size changed to:', this.value);
            updatePlayerOptions();
            const existingError = document.querySelector('.validation-error');
            if (existingError) existingError.remove();
        });
        console.log('‚úì Board size listener attached');
    }
    
    if (aiDifficultySelect) {
        aiDifficultySelect.onchange = null;
        aiDifficultySelect.addEventListener('change', function() {
            console.log('üîÑ AI difficulty changed to:', this.value);
            updateEnhancedDefaultGameName();
        });
        console.log('‚úì AI difficulty listener attached');
    }
    
    // Initialize form state - with delay to ensure all elements are loaded
    setTimeout(() => {
        console.log('üîÑ Initializing room name...');
        updateEnhancedDefaultGameName();
        console.log('‚úì Room name initialized');
    }, 100);
    
    console.log('‚úì Enhanced room creation system ready!');
    
    // Continue with lobby-specific initialization
    if (document.getElementById('available-games')) {
        loadAvailableGames();
    }
    
    if (document.getElementById('my-games')) {
        loadMyGames();
    }
});

console.log('‚úÖ Complete game.js loaded successfully');