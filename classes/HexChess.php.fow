<?php
if (!class_exists('Piece')) {
    require_once __DIR__ . '/Piece.php';
}

class HexChess
{
    public $board;

    private $currentPlayer;
    private $gameId;
    private $players;
    private $playerCount;
    private $moveCount;
    private $boardSize;
    private $activePlayers;
    private $playerUsers; // Maps player slots to user IDs
    private $fogOfWar = false; // NEW: Fog of war setting

    public function __construct($gameId = null, $playerCount = 2, $boardSize = 8, $fogOfWar = false)
    {
        $this->gameId        = $gameId ?: uniqid();
        $this->playerCount   = max(2, min(6, $playerCount));
        $this->currentPlayer = 0;
        $this->moveCount     = 0;
        $this->boardSize     = max(4, min(8, $boardSize));
        $this->playerUsers   = array_fill(0, $this->playerCount, null);
        $this->fogOfWar      = $fogOfWar; // NEW: Store fog of war setting

        // Define player colors for up to 6 players
        $this->players = ['red', 'blue', 'green', 'yellow', 'purple', 'bronze'];
        $this->players = array_slice($this->players, 0, $this->playerCount);

        $this->activePlayers = array_fill(0, $this->playerCount, true);
        $this->initBoard();
    }

    // -------------------------
    // Accessors
    // -------------------------

    public function getBoard()
    {
        return $this->board;
    }

    public function getBoardSize()
    {
        return $this->boardSize;
    }

    public function setPlayerUsers($playerUsers)
    {
        $this->playerUsers = $playerUsers;
    }

    public function getPlayerUsers()
    {
        return $this->playerUsers;
    }

    public function canUserMove($userId)
    {
        return $this->playerUsers[$this->currentPlayer] == $userId;
    }

    // NEW: Fog of war accessors
    public function isFogOfWarEnabled()
    {
        return $this->fogOfWar;
    }

    public function setFogOfWar($enabled)
    {
        $this->fogOfWar = $enabled;
    }

    // -------------------------
    // Player status / resign
    // -------------------------

    public function resignPlayer($playerSlot)
    {
        // Validate player slot
        if ($playerSlot < 0 || $playerSlot >= $this->playerCount) {
            return "Invalid player slot";
        }

        // Check if player is already inactive
        if (!$this->activePlayers[$playerSlot]) {
            return "Player already inactive";
        }

        // Mark player as inactive
        $this->activePlayers[$playerSlot] = false;

        // If it was the current player's turn, advance to next active player
        if ($this->currentPlayer === $playerSlot) {
            $this->advanceToNextActivePlayer();
        }

        // Log the resignation
        error_log("Player $playerSlot ({$this->players[$playerSlot]}) has resigned from game {$this->gameId}");

        return true;
    }

    public function getActivePlayerCount()
    {
        return array_sum($this->activePlayers);
    }

    public function isPlayerActive($playerSlot)
    {
        return isset($this->activePlayers[$playerSlot]) ? $this->activePlayers[$playerSlot] : false;
    }

    public function getActivePlayers()
    {
        return $this->activePlayers;
    }

    // -------------------------
    // Board setup
    // -------------------------

    private function initBoard()
    {
        $this->board = [];

        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for (
                $r = max(-$this->boardSize, -$q - $this->boardSize);
                $r <= min($this->boardSize, -$q + $this->boardSize);
                $r++
            ) {
                $this->board[$q][$r] = null;
            }
        }

        $this->setupPieces();
    }

    private function setupPieces()
    {
        switch ($this->playerCount) {
            case 2:
                $this->setupTwoPlayerPieces();
                break;
            case 3:
                $this->setupThreePlayerPieces();
                break;
            case 4:
                $this->setupFourPlayerPieces();
                break;
            case 5:
                $this->setupFivePlayerPieces();
                break;
            case 6:
                $this->setupSixPlayerPieces();
                break;
            default:
                $this->setupTwoPlayerPieces();
        }
    }

    private function setupTwoPlayerPieces()
    {
        // Player 1 (Red) - left edge
        $this->placePiece(-$this->boardSize, 0, new Piece('king', 0));
        $this->placePiece(-$this->boardSize + 1, -1, new Piece('rook', 0));
        $this->placePiece(-$this->boardSize + 2, -2, new Piece('knight', 0));
        $this->placePiece(-$this->boardSize + 3, -3, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize, 1, new Piece('rook', 0));
        $this->placePiece(-$this->boardSize + 1, 0, new Piece('queen', 0));
        $this->placePiece(-$this->boardSize + 2, -1, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 3, -2, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize, 2, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 1, 1, new Piece('knight', 0));
        $this->placePiece(-$this->boardSize + 2, 0, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 3, -1, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize, 3, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize + 1, 2, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize + 2, 1, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize + 3, 0, new Piece('pawn', 0));

        // Player 2 (Blue) - right edge
        $this->placePiece($this->boardSize, 0, new Piece('king', 1));
        $this->placePiece($this->boardSize - 1, 1, new Piece('rook', 1));
        $this->placePiece($this->boardSize - 2, 2, new Piece('knight', 1));
        $this->placePiece($this->boardSize - 3, 3, new Piece('pawn', 1));
        $this->placePiece($this->boardSize, -1, new Piece('rook', 1));
        $this->placePiece($this->boardSize - 1, 0, new Piece('queen', 1));
        $this->placePiece($this->boardSize - 2, 1, new Piece('bishop', 1));
        $this->placePiece($this->boardSize - 3, 2, new Piece('pawn', 1));
        $this->placePiece($this->boardSize, -2, new Piece('bishop', 1));
        $this->placePiece($this->boardSize - 1, -1, new Piece('knight', 1));
        $this->placePiece($this->boardSize - 2, 0, new Piece('bishop', 1));
        $this->placePiece($this->boardSize - 3, 1, new Piece('pawn', 1));
        $this->placePiece($this->boardSize, -3, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 1, -2, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 2, -1, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 3, 0, new Piece('pawn', 1));
    }

    private function setupThreePlayerPieces()
    {
        // Player 1 (Red) - left edge
        $this->placePiece(-$this->boardSize, 0, new Piece('king', 0));
        $this->placePiece(-$this->boardSize + 1, -1, new Piece('rook', 0));
        $this->placePiece(-$this->boardSize + 2, -2, new Piece('knight', 0));
        $this->placePiece(-$this->boardSize + 3, -3, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize, 1, new Piece('rook', 0));
        $this->placePiece(-$this->boardSize + 1, 0, new Piece('queen', 0));
        $this->placePiece(-$this->boardSize + 2, -1, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 3, -2, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize, 2, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 1, 1, new Piece('knight', 0));
        $this->placePiece(-$this->boardSize + 2, 0, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 3, -1, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize, 3, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize + 1, 2, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize + 2, 1, new Piece('pawn', 0));
        $this->placePiece(-$this->boardSize + 3, 0, new Piece('pawn', 0));

        // Player 2 (Blue) - top-right corner
        $this->placePiece($this->boardSize, -$this->boardSize, new Piece('king', 1));
        $this->placePiece($this->boardSize - 1, -$this->boardSize + 1, new Piece('queen', 1));
        $this->placePiece($this->boardSize - 1, -$this->boardSize, new Piece('rook', 1));
        $this->placePiece($this->boardSize, -$this->boardSize + 1, new Piece('rook', 1));
        $this->placePiece($this->boardSize - 2, -$this->boardSize + 2, new Piece('bishop', 1));
        $this->placePiece($this->boardSize - 2, -$this->boardSize + 1, new Piece('knight', 1));
        $this->placePiece($this->boardSize - 2, -$this->boardSize, new Piece('bishop', 1));
        $this->placePiece($this->boardSize - 1, -$this->boardSize + 2, new Piece('bishop', 1));
        $this->placePiece($this->boardSize, -$this->boardSize + 2, new Piece('knight', 1));
        $this->placePiece($this->boardSize - 3, -$this->boardSize + 3, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 3, -$this->boardSize + 2, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 3, -$this->boardSize + 1, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 3, -$this->boardSize, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 2, -$this->boardSize + 3, new Piece('pawn', 1));
        $this->placePiece($this->boardSize - 1, -$this->boardSize + 3, new Piece('pawn', 1));
        $this->placePiece($this->boardSize, -$this->boardSize + 3, new Piece('pawn', 1));

        // Player 3 (Green) - bottom corner
        $this->placePiece(0, $this->boardSize, new Piece('king', 2));
        $this->placePiece(1, $this->boardSize - 1, new Piece('rook', 2));
        $this->placePiece(2, $this->boardSize - 2, new Piece('knight', 2));
        $this->placePiece(3, $this->boardSize - 3, new Piece('pawn', 2));
        $this->placePiece(-1, $this->boardSize, new Piece('rook', 2));
        $this->placePiece(0, $this->boardSize - 1, new Piece('queen', 2));
        $this->placePiece(1, $this->boardSize - 2, new Piece('bishop', 2));
        $this->placePiece(2, $this->boardSize - 3, new Piece('pawn', 2));
        $this->placePiece(-2, $this->boardSize, new Piece('bishop', 2));
        $this->placePiece(-1, $this->boardSize - 1, new Piece('knight', 2));
        $this->placePiece(0, $this->boardSize - 2, new Piece('bishop', 2));
        $this->placePiece(1, $this->boardSize - 3, new Piece('pawn', 2));
        $this->placePiece(-3, $this->boardSize, new Piece('pawn', 2));
        $this->placePiece(-2, $this->boardSize - 1, new Piece('pawn', 2));
        $this->placePiece(-1, $this->boardSize - 2, new Piece('pawn', 2));
        $this->placePiece(0, $this->boardSize - 3, new Piece('pawn', 2));
    }

    private function setupFourPlayerPieces()
    {
        // Player 0 (Red) - West
        $this->placePiece(-$this->boardSize, 0, new Piece('king', 0));
        $this->placePiece(-$this->boardSize + 1, 0, new Piece('queen', 0));
        $this->placePiece(-$this->boardSize, 1, new Piece('rook', 0));
        $this->placePiece(-$this->boardSize, -1, new Piece('rook', 0));
        $this->placePiece(-$this->boardSize + 1, 1, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 1, -1, new Piece('bishop', 0));
        $this->placePiece(-$this->boardSize + 2, 0, new Piece('knight', 0));
        $this->placePiece(-$this->boardSize + 3, 0, new Piece('pawn', 0));

        // Player 1 (Blue) - North
        $this->placePiece(0, -$this->boardSize, new Piece('king', 1));
        $this->placePiece(0, -$this->boardSize + 1, new Piece('queen', 1));
        $this->placePiece(1, -$this->boardSize, new Piece('rook', 1));
        $this->placePiece(-1, -$this->boardSize, new Piece('rook', 1));
        $this->placePiece(1, -$this->boardSize + 1, new Piece('bishop', 1));
        $this->placePiece(-1, -$this->boardSize + 1, new Piece('bishop', 1));
        $this->placePiece(0, -$this->boardSize + 2, new Piece('knight', 1));
        $this->placePiece(0, -$this->boardSize + 3, new Piece('pawn', 1));

        // Player 2 (Green) - East
        $this->placePiece($this->boardSize, 0, new Piece('king', 2));
        $this->placePiece($this->boardSize - 1, 0, new Piece('queen', 2));
        $this->placePiece($this->boardSize, 1, new Piece('rook', 2));
        $this->placePiece($this->boardSize, -1, new Piece('rook', 2));
        $this->placePiece($this->boardSize - 1, 1, new Piece('bishop', 2));
        $this->placePiece($this->boardSize - 1, -1, new Piece('bishop', 2));
        $this->placePiece($this->boardSize - 2, 0, new Piece('knight', 2));
        $this->placePiece($this->boardSize - 3, 0, new Piece('pawn', 2));

        // Player 3 (Yellow) - South
        $this->placePiece(0, $this->boardSize, new Piece('king', 3));
        $this->placePiece(0, $this->boardSize - 1, new Piece('queen', 3));
        $this->placePiece(1, $this->boardSize, new Piece('rook', 3));
        $this->placePiece(-1, $this->boardSize, new Piece('rook', 3));
        $this->placePiece(1, $this->boardSize - 1, new Piece('bishop', 3));
        $this->placePiece(-1, $this->boardSize - 1, new Piece('bishop', 3));
        $this->placePiece(0, $this->boardSize - 2, new Piece('knight', 3));
        $this->placePiece(0, $this->boardSize - 3, new Piece('pawn', 3));
    }

    private function setupFivePlayerPieces()
    {
        // Basic setup for 5 players - can be enhanced
        $this->setupFourPlayerPieces();
        
        // Player 4 (Purple) - Northwest
        $this->placePiece(-4, -2, new Piece('king', 4));
        $this->placePiece(-3, -2, new Piece('queen', 4));
        $this->placePiece(-4, -1, new Piece('rook', 4));
        $this->placePiece(-3, -1, new Piece('rook', 4));
        $this->placePiece(-2, -2, new Piece('knight', 4));
        $this->placePiece(-2, -1, new Piece('bishop', 4));
        $this->placePiece(-1, -2, new Piece('pawn', 4));
        $this->placePiece(-1, -1, new Piece('pawn', 4));
    }

    private function setupSixPlayerPieces()
    {
        // Basic setup for 6 players - can be enhanced
        $this->setupFourPlayerPieces();
        
        // Player 4 (Purple) - Northwest
        $this->placePiece(-4, -2, new Piece('king', 4));
        $this->placePiece(-3, -2, new Piece('queen', 4));
        $this->placePiece(-4, -1, new Piece('rook', 4));
        $this->placePiece(-3, -1, new Piece('rook', 4));
        $this->placePiece(-2, -2, new Piece('knight', 4));
        $this->placePiece(-2, -1, new Piece('bishop', 4));
        $this->placePiece(-1, -2, new Piece('pawn', 4));
        $this->placePiece(-1, -1, new Piece('pawn', 4));

        // Player 5 (Bronze/Orange) - Southeast
        $this->placePiece(2, 4, new Piece('king', 5));
        $this->placePiece(2, 3, new Piece('queen', 5));
        $this->placePiece(1, 4, new Piece('rook', 5));
        $this->placePiece(1, 3, new Piece('rook', 5));
        $this->placePiece(2, 2, new Piece('knight', 5));
        $this->placePiece(1, 2, new Piece('bishop', 5));
        $this->placePiece(2, 1, new Piece('pawn', 5));
        $this->placePiece(1, 1, new Piece('pawn', 5));
    }

    // -------------------------
    // Piece management
    // -------------------------

    public function getPiece($q, $r)
    {
        if (!$this->isValidHex($q, $r)) {
            return null;
        }
        return $this->board[$q][$r] ?? null;
    }

    public function placePiece($q, $r, $piece)
    {
        if ($this->isValidHex($q, $r)) {
            $this->board[$q][$r] = $piece;
        }
    }

    public function isValidHex($q, $r)
    {
        return abs($q) <= $this->boardSize && 
               abs($r) <= $this->boardSize && 
               abs($q + $r) <= $this->boardSize;
    }

    // Demo methods
    public function clearBoard()
    {
        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                $this->board[$q][$r] = null;
            }
        }
    }

    public function placeDemoPiece($q, $r, $piece)
    {
        $this->placePiece($q, $r, $piece);
    }

    // -------------------------
    // Move processing
    // -------------------------

    public function movePiece($fromQ, $fromR, $toQ, $toR)
    {
        if (!$this->isValidMove($fromQ, $fromR, $toQ, $toR)) {
            return false;
        }

        $piece                      = $this->board[$fromQ][$fromR];
        $this->board[$toQ][$toR]    = $piece;
        $this->board[$fromQ][$fromR] = null;

        $this->moveCount++;
        $this->checkForEliminations();
        $this->advanceToNextActivePlayer();

        return true;
    }

    private function advanceToNextActivePlayer()
    {
        $attempts = 0;
        do {
            $this->currentPlayer = ($this->currentPlayer + 1) % $this->playerCount;
            $attempts++;

            // Prevent infinite loop if all players are inactive
            if ($attempts > $this->playerCount) {
                error_log("Warning: Could not find active player in game {$this->gameId}");
                break;
            }
        } while (!$this->activePlayers[$this->currentPlayer] && $this->getActivePlayerCount() > 1);

        // Log turn change for debugging
        if ($this->getActivePlayerCount() > 1) {
            error_log("Turn advanced to player {$this->currentPlayer} ({$this->players[$this->currentPlayer]}) in game {$this->gameId}");
        }
    }

    private function checkForEliminations()
    {
        for ($player = 0; $player < $this->playerCount; $player++) {
            if ($this->activePlayers[$player] && $this->isCheckmate($player)) {
                $this->activePlayers[$player] = false;
            }
        }
    }

    public function isValidMove($fromQ, $fromR, $toQ, $toR)
    {
        $piece = $this->getPiece($fromQ, $fromR);

        if (!$piece) {
            return false;
        }
        if ($piece->player !== $this->currentPlayer || !$this->activePlayers[$this->currentPlayer]) {
            return false;
        }
        if (!$this->isValidHex($toQ, $toR)) {
            return false;
        }
        if ($fromQ === $toQ && $fromR === $toR) {
            return false;
        }

        $targetPiece = $this->getPiece($toQ, $toR);
        if ($targetPiece && $targetPiece->player === $this->currentPlayer) {
            return false;
        }

        if (!$this->canPieceMoveTo($piece, $fromQ, $fromR, $toQ, $toR)) {
            return false;
        }

        if ($this->moveCount >= 2) {
            if ($this->wouldLeaveKingInCheck($fromQ, $fromR, $toQ, $toR, $this->currentPlayer)) {
                return false;
            }
        }

        return true;
    }

    private function canPieceMoveTo($piece, $fromQ, $fromR, $toQ, $toR)
    {
        $dq = $toQ - $fromQ;
        $dr = $toR - $fromR;

        switch ($piece->type) {
            case 'pawn':
                return $this->canPawnMove($piece, $fromQ, $fromR, $toQ, $toR);

            case 'rook':
                return $this->isOrthogonalMove($dq, $dr) && $this->isPathClear($fromQ, $fromR, $toQ, $toR);

            case 'bishop':
                return $this->isDiagonalMove($dq, $dr) && $this->isPathClear($fromQ, $fromR, $toQ, $toR);

            case 'knight':
                $knightMoves = [
                    [2, 1], [3, -1], [1, 2], [-1, 3], [-2, 3], [-3, 2],
                    [-3, 1], [-2, -1], [-1, -2], [1, -3], [2, -3], [3, -2],
                ];

                foreach ($knightMoves as $move) {
                    if ($dq === $move[0] && $dr === $move[1]) {
                        return true;
                    }
                }
                return false;

            case 'queen':
                return ($this->isOrthogonalMove($dq, $dr) || $this->isDiagonalMove($dq, $dr)) 
                       && $this->isPathClear($fromQ, $fromR, $toQ, $toR);

            case 'king':
                return max(abs($dq), abs($dr), abs($dq + $dr)) === 1;

            default:
                return false;
        }
    }

    private function canPawnMove($piece, $fromQ, $fromR, $toQ, $toR)
    {
        $dq = $toQ - $fromQ;
        $dr = $toR - $fromR;

        // --- 2 players ---
        if ($this->playerCount == 2) {
            if ($piece->player == 0) { // Red (west edge) forward E
                if ($dq == 1 && $dr == 0) {
                    return !$this->getPiece($toQ, $toR);
                }
                if (($dq == 1 && $dr == 1) || ($dq == 2 && $dr == -1)) {
                    $t = $this->getPiece($toQ, $toR);
                    return $t && $t->player !== $piece->player;
                }
            } else { // Blue (east edge) forward W
                if ($dq == -1 && $dr == 0) {
                    return !$this->getPiece($toQ, $toR);
                }
                if (($dq == -1 && $dr == -1) || ($dq == -2 && $dr == 1)) {
                    $t = $this->getPiece($toQ, $toR);
                    return $t && $t->player !== $piece->player;
                }
            }
            return false;
        }

        // --- 3+ players (simplified) ---
        if ($this->playerCount >= 3) {
            switch ($piece->player) {
                case 0: // Red (west) forward E
                    if ($dq == 1 && $dr == 0) return !$this->getPiece($toQ, $toR);
                    if (($dq == 1 && $dr == 1) || ($dq == 2 && $dr == -1)) {
                        $t = $this->getPiece($toQ, $toR); return $t && $t->player !== $piece->player;
                    }
                    return false;

                case 1: // Blue (NE) forward SW
                    if ($dq == -1 && $dr == 1) return !$this->getPiece($toQ, $toR);
                    if (($dq == -2 && $dr == 1) || ($dq == -1 && $dr == 2)) {
                        $t = $this->getPiece($toQ, $toR); return $t && $t->player !== $piece->player;
                    }
                    return false;

                case 2: // Green (SE) forward NW
                    if ($dq == 0 && $dr == -1) return !$this->getPiece($toQ, $toR);
                    if (($dq == -1 && $dr == -1) || ($dq == 1 && $dr == -2)) {
                        $t = $this->getPiece($toQ, $toR); return $t && $t->player !== $piece->player;
                    }
                    return false;

                default:
                    // Basic forward move for players 3+
                    return abs($dq) + abs($dr) <= 2;
            }
        }

        return false;
    }

    private function isOrthogonalMove($dq, $dr)
    {
        return ($dq == 0 && $dr != 0) || ($dr == 0 && $dq != 0) || ($dq + $dr == 0);
    }

/*
private function isDiagonalMove($dq, $dr)
{
    // Three diagonal axes in hex coordinates
    return ($dq != 0 && $dr != 0 && $dq + $dr != 0 && 
            (abs($dq) == abs($dr) || abs($dq) == abs($dq + $dr) || abs($dr) == abs($dq + $dr)));
}
*/

private function isDiagonalMove($dq, $dr)
{
    // Exclude orthogonal moves first
    if ($dq == 0 || $dr == 0 || ($dq + $dr) == 0) {
        return false;
    }
    
    // Now check the three diagonal axes
    return abs($dq) == abs($dr) || abs($dq) == abs($dq + $dr) || abs($dr) == abs($dq + $dr);
}

    private function isPathClear($fromQ, $fromR, $toQ, $toR)
    {
        $dq = $toQ - $fromQ;
        $dr = $toR - $fromR;
        $steps = max(abs($dq), abs($dr), abs($dq + $dr));

        if ($steps <= 1) return true;

        $stepQ = $dq / $steps;
        $stepR = $dr / $steps;

        for ($i = 1; $i < $steps; $i++) {
            $checkQ = $fromQ + round($stepQ * $i);
            $checkR = $fromR + round($stepR * $i);

            if ($this->getPiece($checkQ, $checkR) !== null) {
                return false;
            }
        }

        return true;
    }

    // -------------------------
    // Game state checking
    // -------------------------

    private function findKing($player)
    {
        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                
                $piece = $this->getPiece($q, $r);
                if ($piece && $piece->type === 'king' && $piece->player === $player) {
                    return ['q' => $q, 'r' => $r];
                }
            }
        }
        return null;
    }

    private function isKingInCheck($player)
    {
        $king = $this->findKing($player);
        if (!$king) return false;

        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                
                $piece = $this->getPiece($q, $r);
                if ($piece && $piece->player !== $player) {
                    if ($this->canPieceMoveTo($piece, $q, $r, $king['q'], $king['r'])) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private function wouldLeaveKingInCheck($fromQ, $fromR, $toQ, $toR, $player)
    {
        $piece = $this->getPiece($fromQ, $fromR);
        $capturedPiece = $this->getPiece($toQ, $toR);

        $this->board[$toQ][$toR] = $piece;
        $this->board[$fromQ][$fromR] = null;

        $inCheck = $this->isKingInCheck($player);

        $this->board[$fromQ][$fromR] = $piece;
        $this->board[$toQ][$toR] = $capturedPiece;

        return $inCheck;
    }

    private function hasLegalMoves($player)
    {
        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                
                $piece = $this->getPiece($q, $r);
                if ($piece && $piece->player === $player) {
                    if ($this->pieceHasLegalMoves($q, $r)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private function pieceHasLegalMoves($fromQ, $fromR)
    {
        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                
                if ($this->isValidMove($fromQ, $fromR, $q, $r)) {
                    return true;
                }
            }
        }
        return false;
    }

    private function isCheckmate($player)
    {
        return $this->isKingInCheck($player) && !$this->hasLegalMoves($player);
    }

    private function isStalemate($player)
    {
        return !$this->isKingInCheck($player) && !$this->hasLegalMoves($player);
    }

    // -------------------------
    // FOG OF WAR IMPLEMENTATION - FIXED VERSION
    // -------------------------

    /**
     * ENHANCED: Get all pieces visible to a specific player under fog of war rules
     * Returns array of coordinates [q, r] where enemy pieces should be visible
     */
    public function getVisibleEnemyPieces($playerSlot)
    {
        if (!$this->fogOfWar) {
            // If fog of war is disabled, all pieces are visible
            return $this->getAllPiecePositions();
        }
        
        $visiblePositions = [];
        
        // Get all friendly piece positions
        $friendlyPieces = $this->getPlayerPieces($playerSlot);
        
        error_log("FOG DEBUG: Player $playerSlot has " . count($friendlyPieces) . " friendly pieces");
        
        foreach ($friendlyPieces as $friendlyPos) {
            $friendlyPiece = $this->getPiece($friendlyPos['q'], $friendlyPos['r']);
            
            if (!$friendlyPiece) continue;
            
            error_log("FOG DEBUG: Checking visibility from {$friendlyPiece->type} at ({$friendlyPos['q']}, {$friendlyPos['r']})");
            
            // Check all positions this friendly piece can attack
            $attackablePositions = $this->getAttackablePositions($friendlyPiece, $friendlyPos['q'], $friendlyPos['r']);
            
            error_log("FOG DEBUG: {$friendlyPiece->type} can attack " . count($attackablePositions) . " positions");
            
            foreach ($attackablePositions as $pos) {
                $enemyPiece = $this->getPiece($pos['q'], $pos['r']);
                if ($enemyPiece && $enemyPiece->player !== $playerSlot) {
                    $visiblePositions[] = $pos;
                    error_log("FOG DEBUG: Can see enemy {$enemyPiece->type} at ({$pos['q']}, {$pos['r']}) via attack");
                }
            }
            
            // Also check adjacent positions for enemy pieces
            $adjacentPositions = $this->getAdjacentPositions($friendlyPos['q'], $friendlyPos['r']);
            
            foreach ($adjacentPositions as $pos) {
                $enemyPiece = $this->getPiece($pos['q'], $pos['r']);
                if ($enemyPiece && $enemyPiece->player !== $playerSlot) {
                    $visiblePositions[] = $pos;
                    error_log("FOG DEBUG: Can see adjacent enemy {$enemyPiece->type} at ({$pos['q']}, {$pos['r']})");
                }
            }
        }
        
        // Remove duplicates
        $uniqueVisible = $this->removeDuplicatePositions($visiblePositions);
        error_log("FOG DEBUG: Total visible enemy pieces: " . count($uniqueVisible));
        
        return $uniqueVisible;
    }

    /**
     * Get all pieces belonging to a specific player
     */
    private function getPlayerPieces($playerSlot)
    {
        $pieces = [];
        
        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                
                $piece = $this->getPiece($q, $r);
                if ($piece && $piece->player === $playerSlot) {
                    $pieces[] = ['q' => $q, 'r' => $r, 'piece' => $piece];
                }
            }
        }
        
        return $pieces;
    }

    /**
     * Get all positions a piece can attack from its current position
     */
    private function getAttackablePositions($piece, $fromQ, $fromR)
    {
        $attackablePositions = [];
        
        // Check all valid board positions
        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                
                // Skip the piece's own position
                if ($q === $fromQ && $r === $fromR) continue;
                
                // Check if this piece can attack this position
                if ($this->canPieceAttack($piece, $fromQ, $fromR, $q, $r)) {
                    $attackablePositions[] = ['q' => $q, 'r' => $r];
                }
            }
        }
        
        return $attackablePositions;
    }

    /**
     * FIXED: Check if a piece can attack a specific position
     */
    private function canPieceAttack($piece, $fromQ, $fromR, $toQ, $toR)
    {
        // Don't attack your own position
        if ($fromQ === $toQ && $fromR === $toR) {
            return false;
        }
        
        $dq = $toQ - $fromQ;
        $dr = $toR - $fromR;
        
        switch ($piece->type) {
            case 'pawn':
                // Pawns can only attack diagonally, not move forward for attacks
                return $this->canPawnAttack($piece, $fromQ, $fromR, $toQ, $toR);
                
            case 'rook':
                return $this->isOrthogonalMove($dq, $dr) && $this->isPathClear($fromQ, $fromR, $toQ, $toR);
                
            case 'bishop':
                return $this->isDiagonalMove($dq, $dr) && $this->isPathClear($fromQ, $fromR, $toQ, $toR);
                
            case 'knight':
                return $this->isKnightMove($dq, $dr);
                
            case 'queen':
                return ($this->isOrthogonalMove($dq, $dr) || $this->isDiagonalMove($dq, $dr)) 
                       && $this->isPathClear($fromQ, $fromR, $toQ, $toR);
                       
            case 'king':
                return $this->isAdjacentMove($dq, $dr);
                
            default:
                return false;
        }
    }

    /**
     * Check if pawn can attack a position (diagonal captures only)
     */
    private function canPawnAttack($piece, $fromQ, $fromR, $toQ, $toR)
    {
        $dq = $toQ - $fromQ;
        $dr = $toR - $fromR;
        
        // Use the existing pawn movement logic but only return true for capture moves
        if ($this->playerCount == 2) {
            if ($piece->player == 0) { // Red pawn
                return ($dq == 1 && $dr == 1) || ($dq == 2 && $dr == -1);
            } else { // Blue pawn
                return ($dq == -1 && $dr == -1) || ($dq == -2 && $dr == 1);
            }
        }
        
        // For 3+ players, use the capture patterns from canPawnMove
        if ($this->playerCount >= 3) {
            switch ($piece->player) {
                case 0: // Red
                    return ($dq == 1 && $dr == 1) || ($dq == 2 && $dr == -1);
                case 1: // Blue
                    return ($dq == -2 && $dr == 1) || ($dq == -1 && $dr == 2);
                case 2: // Green
                    return ($dq == -1 && $dr == -1) || ($dq == 1 && $dr == -2);
                default:
                    // Basic attack pattern for additional players
                    return abs($dq) + abs($dr) == 2 && max(abs($dq), abs($dr)) == 1;
            }
        }
        
        return false;
    }

    /**
     * Check if move is a knight move pattern
     */
    private function isKnightMove($dq, $dr)
    {
        $knightMoves = [
            [2, 1], [3, -1], [1, 2], [-1, 3], [-2, 3], [-3, 2],
            [-3, 1], [-2, -1], [-1, -2], [1, -3], [2, -3], [3, -2],
        ];
        
        foreach ($knightMoves as $move) {
            if ($dq === $move[0] && $dr === $move[1]) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if move is adjacent (king move)
     */
    private function isAdjacentMove($dq, $dr)
    {
        return max(abs($dq), abs($dr), abs($dq + $dr)) === 1;
    }

    /**
     * Get all positions adjacent to a given position
     */
    private function getAdjacentPositions($q, $r)
    {
        $adjacent = [];
        $directions = [
            [1, 0], [-1, 0], [0, 1], [0, -1], [1, -1], [-1, 1]
        ];
        
        foreach ($directions as $dir) {
            $newQ = $q + $dir[0];
            $newR = $r + $dir[1];
            
            if ($this->isValidHex($newQ, $newR)) {
                $adjacent[] = ['q' => $newQ, 'r' => $newR];
            }
        }
        
        return $adjacent;
    }

    /**
     * Get all piece positions on the board (for when fog of war is disabled)
     */
    private function getAllPiecePositions()
    {
        $positions = [];
        
        for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
            for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
                 $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
                
                if ($this->getPiece($q, $r)) {
                    $positions[] = ['q' => $q, 'r' => $r];
                }
            }
        }
        
        return $positions;
    }

    /**
     * Remove duplicate positions from array
     */
    private function removeDuplicatePositions($positions)
    {
        $unique = [];
        $seen = [];
        
        foreach ($positions as $pos) {
            $key = $pos['q'] . ',' . $pos['r'];
            if (!isset($seen[$key])) {
                $seen[$key] = true;
                $unique[] = $pos;
            }
        }
        
        return $unique;
    }

    /**
     * Check if a piece position should be visible to a player
     */
    public function isPieceVisibleToPlayer($pieceQ, $pieceR, $viewerPlayerSlot)
    {
        $piece = $this->getPiece($pieceQ, $pieceR);
        
        if (!$piece) {
            return false; // No piece at position
        }
        
        if ($piece->player === $viewerPlayerSlot) {
            return true; // Own pieces are always visible
        }
        
        if (!$this->fogOfWar) {
            return true; // All pieces visible when fog of war is disabled
        }
        
        // Check if this enemy piece is in the visible list
        $visibleEnemies = $this->getVisibleEnemyPieces($viewerPlayerSlot);
        
        foreach ($visibleEnemies as $visiblePos) {
            if ($visiblePos['q'] === $pieceQ && $visiblePos['r'] === $pieceR) {
                return true;
            }
        }
        
        return false; // Enemy piece not visible under fog of war
    }

    /**
     * NEW: Get all valid moves for a piece (required for fog of war move filtering)
     */
     /*
public function getValidMoves($fromQ, $fromR) 
{
    $validMoves = [];
    $piece = $this->getPiece($fromQ, $fromR);
    
    if (!$piece) {
        return $validMoves;
    }
    
    // Temporarily bypass turn checking for move highlighting
    $originalPlayer = $this->currentPlayer;
    $this->currentPlayer = $piece->player;
    
    for ($q = -$this->boardSize; $q <= $this->boardSize; $q++) {
        for ($r = max(-$this->boardSize, -$q - $this->boardSize); 
             $r <= min($this->boardSize, -$q + $this->boardSize); $r++) {
            
            if ($this->isValidMove($fromQ, $fromR, $q, $r)) {
                $targetPiece = $this->getPiece($q, $r);
                $validMoves[] = [
                    'q' => $q,
                    'r' => $r,
                    'type' => $targetPiece ? 'capture' : 'move'
                ];
            }
        }
    }
    
    // Restore original current player
    $this->currentPlayer = $originalPlayer;
    
    return $validMoves;
}
*/

    // -------------------------
    // Misc helpers
    // -------------------------

    public function getCurrentPlayer()
    {
        return $this->players[$this->currentPlayer];
    }

    public function getCurrentPlayerSlot()
    {
        return $this->currentPlayer;
    }

    public function getPlayerCount()
    {
        return $this->playerCount;
    }

    public function getPlayers()
    {
        return $this->players;
    }

public function getCellColor($q, $r)
{
    $colorIndex = (($q - $r) % 3 + 3) % 3;
    $colors = ['pastel-red', 'pastel-green', 'pastel-blue'];
    return $colors[$colorIndex];  // Not $colorClass
}

    public function getGameState()
    {
        $activePlayerCount = $this->getActivePlayerCount();
        $gameOver          = $activePlayerCount <= 1;
        $winner            = null;

        if ($gameOver && $activePlayerCount == 1) {
            // Find the last active player as winner
            for ($player = 0; $player < $this->playerCount; $player++) {
                if ($this->activePlayers[$player]) {
                    $winner = $this->playerUsers[$player];
                    break;
                }
            }
        } elseif ($gameOver && $activePlayerCount == 0) {
            // All players resigned or eliminated - no winner
            $winner = null;
        }

        // Find kings in check for highlighting
        $kingsInCheck = [];
        for ($player = 0; $player < $this->playerCount; $player++) {
            if ($this->activePlayers[$player]) {
                $kingPos = $this->findKing($player);
                if ($kingPos && $this->isKingInCheck($player)) {
                    $kingsInCheck[] = $kingPos;
                }
            }
        }

        return [
            'gameId'       => $this->gameId,
            'currentPlayer'=> $this->currentPlayer,
            'playerCount'  => $this->playerCount,
            'moveCount'    => $this->moveCount,
            'board'        => $this->board,
            'gameStatus'   => [
                'gameOver'          => $gameOver,
                'winner'            => $winner,
                'activePlayerCount' => $activePlayerCount,
            ],
            'activePlayers'=> $this->activePlayers,
            'playerUsers'  => $this->playerUsers,
            'isInCheck'    => $this->activePlayers[$this->currentPlayer] ? $this->isKingInCheck($this->currentPlayer) : false,
            'kingsInCheck' => $kingsInCheck,
            'fogOfWar'     => $this->fogOfWar, // NEW: Include fog of war state
        ];
    }
}
?>